<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我会构建健壮的多线程电梯评测机</title>
      <link href="/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/"/>
      <url>/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="我会构建健壮的多线程电梯评测机-smiley"><a href="#我会构建健壮的多线程电梯评测机-smiley" class="headerlink" title="我会构建健壮的多线程电梯评测机:smiley:"></a>我会构建健壮的多线程电梯评测机:smiley:</h1><p>已同步更新至本人blog，欢迎大家来参观:blush:</p><p>对于像电梯这样的复杂的、行为不确定的并发系统，<strong>构建自动化、系统化、能够进行状态跟踪和规则检查的测试框架，是确保程序正确性、提高开发效率的必备手段</strong>。直接手动测试覆盖面有限，且难以复现并发问题。因此，构建一个自动化的、能够生成有强度数据的、能够精确判定正确性的评测机就显得尤为必要。<del>同学，你也不想你的代码被我们hack吧</del></p><p>在经历了 HW5 到 HW6 的迭代后，电梯系统的规则变得更加复杂。在此之前，我和舍友合力搭建了一套基于 Python 的自动化评测框架，希望能较为全面地测试电梯程序的健壮性和性能。经过了一次迭代，该评测机的性能和正确性能够做到更优。在此，我想分享一下这套评测机的核心思路和实现细节，希望能为大家提供一些参考</p><h2 id="一、-核心组件概览"><a href="#一、-核心组件概览" class="headerlink" title="一、 核心组件概览"></a>一、 核心组件概览</h2><p>我们的评测机主要由以下 Python 脚本构成：</p><ol><li><p><strong><code>generate_data.py</code></strong>: 负责生成符合要求的、具有不同侧重点和强度的测试输入数据 (<code>stdin.txt</code>)，包括乘客请求和临时调度 (SCHE) 请求</p></li><li><p><strong><code>validator.py</code></strong>: 核心验证逻辑所在。它读取输入数据，模拟电梯系统的预期行为，并逐行解析、验证程序的输出 (<code>stdout</code>) 是否符合指导书的所有正确性约束（时序、状态、规则等）</p></li><li><p><strong><code>run_test.py</code></strong>: 测试流程的“指挥官”。它负责调用数据生成器、在隔离环境中执行同学们的 Java 程序（通过官方提供的 <code>datainput.exe</code> 和 <code>java</code> 命令）、捕获输出、调用验证器进行判定，并最终汇总、报告测试结果</p></li><li><p>**<code>run_elevator_tests.bat</code> **: 一个简单的启动脚本，方便一键运行</p><p><img src="E:\OO\讨论区帖子\我会构建健壮的多线程电梯评测机\核心组件.png" alt="核心组件"></p></li></ol><h2 id="二、-数据生成策略-generate-data-py"><a href="#二、-数据生成策略-generate-data-py" class="headerlink" title="二、 数据生成策略 (generate_data.py)"></a>二、 数据生成策略 (<code>generate_data.py</code>)</h2><p>生成高质量的测试数据是评测有效性的基础。我们的目标是覆盖各种边界情况和压力场景:smiling_imp:</p><p>这是保证我们评测机强度的核心了。之前我在高强度水群的时候发现，某位同学说ta的评测机跑了一整天全是AC </p><p>那当然是测试点强度还不够啦！尽管是随机生成，我们也要有策略、有侧重点地随机生成，不给点压力，你怎么知道代码会不会垮掉呢？<del>嘻嘻</del></p><p><strong>核心思路：分阶段、有侧重地生成请求。</strong></p><p>我们将总的模拟时间（公测约 60s+，互测 50s）划分为四个阶段，每个阶段投放不同特点的请求：</p><ul><li><strong>阶段一 (0% - 15% 时间, ~10% 请求): 稀疏试探</strong><ul><li><strong>目的</strong>: 模拟系统启动初期或低峰期，请求零散</li><li><strong>内容</strong>: 生成少量乘客请求，优先级随机偏低，并夹杂少量 SCHE 请求。测试电梯的启动、基本寻路和 SCHE 响应能力</li></ul></li><li><strong>阶段二 (15% - 50% 时间, ~40% 请求): 密集压力 I</strong><ul><li><strong>目的</strong>: 模拟高峰期，测试系统的吞吐能力和调度策略在高负载下的表现，<del>就好比下课时间大家蜂拥去食堂</del></li><li><strong>内容</strong>: 大量乘客请求涌入，时间戳<strong>相近</strong>或<strong>相同</strong>。乘客请求可能跨度较大。也包含一些 SCHE 请求，测试调度中断和恢复能力</li></ul></li><li><strong>阶段三 (50% - 75% 时间, ~20% 请求): 边界与特殊场景</strong><ul><li><strong>目的</strong>: 专门测试指导书中提到的或容易出错的边界情况</li><li><strong>内容</strong>:<ul><li><strong>极端距离</strong>: 如 B4 &lt;-&gt; F7。</li><li><strong>跨零层</strong>: 如 B1 &lt;-&gt; F1。</li><li><strong>短距离</strong>: 相邻楼层。</li><li><strong>SCHE 边界</strong>: 测试 SCHE 请求与普通请求的交互、SCHE 的快速响应、SCHE 期间乘客处理、完成 SCHE 需要的总时间等。生成 SCHE 请求时，会保守估计上一个 SCHE 的完成时间，确保两次 SCHE 之间有足够间隔</li></ul></li></ul></li><li><strong>阶段四 (75% - 100% 时间, ~30% 请求): 优先级与密集压力 II</strong><ul><li><strong>目的</strong>: 测试调度策略对优先级的响应，以及在接近结束时处理剩余请求的能力。很多同学想必都对优先级进行过优化，那么自然要有针对性的找问题，<del>桀桀桀</del></li><li><strong>内容</strong>: 生成大量同时间戳请求，这些请求中有极高优先级 (80-100) 和极低优先级 (1-10) 的请求，集中hack同学们针对优先级优化的地方。同时保持一定的请求密度。也包含 SCHE 请求</li></ul></li></ul><p><strong>其他生成细节:</strong></p><ul><li><strong>互测模式约束</strong>: 当检测到是互测模式时：<ul><li>最大数据投喂时间强制设为 50s</li><li>总请求数（乘客 + SCHE）严格控制在 70 条以内</li><li>每部电梯的 SCHE 请求数严格控制在 1 次以内</li></ul></li><li><strong>时间戳</strong>:<ul><li>保证第一条指令 <code>&gt;= 1.0s</code></li><li>使用插入并最后排序，确保输入文件中的精确时间戳<strong>非递减</strong></li><li>在最终输出到 <code>stdin.txt</code> 时，检查确保格式化后的时间戳也是<strong>非递减</strong>的（通过与上一个输出的时间戳比较调整）</li><li>添加微小随机扰动，避免大量完全相同的时间戳</li></ul></li></ul><h2 id="三、-正确性判定-validator-py"><a href="#三、-正确性判定-validator-py" class="headerlink" title="三、 正确性判定 (validator.py)"></a>三、 正确性判定 (<code>validator.py</code>)</h2><p>这是评测机的核心和最复杂的部分。它的运行思路是<strong>基于学生程序的输出日志，精确模拟电梯和乘客的状态变化，并根据指导书的所有规则进行校验</strong>，<del>当然，这也是和大模型经过深刻交流后诞生的</del></p><p><strong>核心思路：状态机模拟 + 规则校验</strong></p><ol><li><p><strong>状态建模</strong>:</p><ul><li><code>PassengerState</code><strong>乘客状态</strong>: 记录每个乘客的 ID, 优先级, 起止楼层, 请求时间, <strong>当前位置</strong>, 当前状态, <strong>所在电梯</strong>, 以及<strong>被哪个电梯接收</strong></li><li><code>ElevatorState</code><strong>电梯状态</strong>: 记录电梯 ID, 当前楼层, 门状态, <strong>轿厢内乘客集合</strong>, <strong>已接收待处理乘客集合</strong>, 当前速度, <strong>调度状态</strong>, 临时调度信息, 以及<strong>上次动作完成时间</strong> 用于时序检查。</li></ul></li><li><p><strong>输出解析</strong>:</p><ul><li>逐行读取 <code>stdout</code>。</li><li>使用正则表达式精确匹配时间戳和事件内容。采用 <code>re.fullmatch</code> 确保内容完全符合预期格式。</li><li>解析出事件类型和参数（楼层、ID、速度等），进行基本类型和范围检查（如楼层是否有效，ID 是否在 1-6）。</li><li>时间戳检查: 全局检查输出时间戳是否非递减。</li></ul></li><li><p><strong>事件验证</strong>: 这个是正确性判定的关键了。对每个解析出的事件，根据当前模拟的系统状态（所有电梯和乘客的状态）和指导书规则进行检查：</p><ul><li><p><strong>基本移动 (<code>ARRIVE</code>)</strong>:</p><ul><li>检查门是否关闭</li><li>检查时间是否满足 <code>当前速度 * 1 层</code> 的要求（与上次动作完成时间比较，允许一定误差）</li><li>检查移动是否合法（相邻楼层或跨零层）</li><li>检查电梯在空闲时（无乘客、无接收）是否在 <code>RECEIVE</code> 后才移动（基础检查）</li></ul></li><li><p><strong>开关门 (<code>OPEN</code>&#x2F;<code>CLOSE</code>)</strong>:</p><ul><li>检查前置状态<del>开门前必须关门，关门前必须开门</del></li><li>检查是否在当前楼层操作</li><li>检查 <code>CLOSE</code> 距离对应的 <code>OPEN</code> 是否满足最小开门时间（普通 <code>0.4s</code>，SCHE 目标层 <code>1.0s</code>）</li></ul></li><li><p><strong>进出乘客 (<code>IN</code>&#x2F;<code>OUT</code>)</strong>:</p><ul><li>检查门是否打开</li><li>检查是否在电梯当前楼层</li><li><code>IN</code>: 检查电梯容量是否合法；检查乘客是否在当前楼层；<strong>检查乘客是否已被该电梯 <code>RECEIVE</code></strong>；<em>重要：<code>IN</code> 在电梯处于调度状态下禁止</em>。</li><li><code>OUT</code>: 检查乘客是否在该电梯内部；根据 <code>OUT-S</code>&#x2F;<code>OUT-F</code> 和是否到达目的地判断标志是否正确</li><li>状态更新：正确更新乘客的状态，包括所处楼层或所处电梯等</li></ul></li><li><p><strong>接收 (<code>RECEIVE</code>)</strong>:</p><ul><li><p>检查乘客是否处于等待电梯的状态中</p></li><li><p>检查乘客是否已被<strong>其他</strong>电梯接收</p></li><li><p>检查是否<strong>重复接收</strong>同一乘客</p><p>举个例子，下面是判定接受成功的部分代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function validate_receive(event):</span><br><span class="line">passenger = get_passenger(event.person_id)</span><br><span class="line">elevator = get_elevator(event.elevator_id)</span><br><span class="line">is_sche_active = (elevator.scheduling_state == ACTIVE)</span><br><span class="line"></span><br><span class="line">if is_sche_active://电梯仍在SCHE中</span><br><span class="line">    add_error(&quot;RECEIVE during SCHE ACTIVE&quot;)</span><br><span class="line">if passenger.state != WAITING: //乘客不属于等待状态（未投喂请求、已进入电梯等）</span><br><span class="line">    add_error(&quot;RECEIVE Passenger not WAITING&quot;)</span><br><span class="line">// 关键：检查是否已被任何电梯接收 (包括自己)</span><br><span class="line">if passenger.received_by_elevator != -1:</span><br><span class="line">     if passenger.received_by_elevator != event.elevator_id:</span><br><span class="line">         add_error(&quot;Passenger already received by another elevator&quot;)</span><br><span class="line">     else:</span><br><span class="line">         add_error(&quot;Duplicate RECEIVE by same elevator&quot;)</span><br><span class="line"></span><br><span class="line">// 如果检查通过:</span><br><span class="line">passenger.received_by_elevator = event.elevator_id</span><br><span class="line">elevator.received_passengers.add(event.person_id)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>临时调度 (<code>SCHE-ACCEPT</code>, <code>SCHE-BEGIN</code>, <code>SCHE-END</code>)</strong>:</p><ul><li><code>SCHE-ACCEPT</code>: 从输出解析，更新电梯状态为，记录调度信息（允许覆盖）。</li><li><code>SCHE-BEGIN</code>: 检查电梯是否处于接受调度状态；检查门是否关闭；检查电梯是否静止；检查距离 <code>SCHE-ACCEPT</code> 的 <code>ARRIVE</code> 次数 (<code>&lt;= 2</code>)；<strong>关键：将该电梯所有的已经<code>RECEIVE</code>到的乘客状态设为未接收，并清空电梯的“已RECEIVE乘客”集合</strong>；设置状态为处于临时调度中，更新运行速度。</li><li><code>SCHE-END</code>: <strong>检查电梯是否处于临时调度中</strong>；检查电梯是否在目标楼层；检查是否空载；检查门是否 <code>CLOSED</code>；检查总响应时间（不能超过6s）；检查之前是否有合法的 <code>OPEN</code> -&gt; (等待1s) -&gt; <code>CLOSE</code> 序列；设置状态为正常，恢复默认速度。</li></ul></li></ul></li><li><p><strong>最终状态检查</strong>:</p><ul><li>所有乘客状态是否为 <code>ARRIVED</code>。</li><li>所有电梯状态是否为 <code>IDLE</code>，是否空载，门是否 <code>CLOSED</code>，速度是否恢复默认。</li></ul></li></ol><h2 id="四、-自动化与执行流程-run-test-py"><a href="#四、-自动化与执行流程-run-test-py" class="headerlink" title="四、 自动化与执行流程 (run_test.py)"></a>四、 自动化与执行流程 (<code>run_test.py</code>)</h2><p>为了方便、高效地进行大量测试，自动化流程必不可少，你也很喜欢点点鼠标就自动开始评测对吧:yum:</p><ol><li><p><strong>模式选择</strong>: 启动时询问用户选择“公测”或“互测”模式，加载对应的参数（如最大请求投喂时间，数据生成范围等）</p></li><li><p><strong>并行测试</strong>: 使用 <code>concurrent.futures.ProcessPoolExecutor</code> 并行运行多个测试实例，显著缩短总测试时间</p></li><li><p><strong>环境隔离</strong>:</p><ul><li>为每个测试实例创建一个独立的子目录</li><li>将学生的代码 JAR包、官方的JAR包和数据投喂包复制到子目录中</li><li>在该子目录中生成独立的 <code>stdin.txt</code></li><li><strong>作用</strong>: 防止不同测试实例之间因共享文件或状态产生干扰，确保测试的可重复性</li></ul></li><li><p><strong>命令执行与 I&#x2F;O</strong>:</p><ul><li>使用 <code>subprocess.Popen</code> 在子目录中执行数据投喂命令</li><li>通过管道捕获 Java 程序的 <code>stdout</code> 和 <code>stderr</code></li><li>设置超时 (<code>timeout</code> 参数)，在超时后将超时判断设置为真</li></ul></li><li><p><strong>超时处理</strong>: 即使进程超时，仍会<strong>尝试读取已有的输出</strong>，并<strong>继续执行验证逻辑</strong>。最终结果会被标记为 <code>FAIL_TIMEOUT</code>，但日志中会包含验证器对部分输出的检查结果，有助于分析超时前的行为。</p></li><li><p><strong>Stderr 检查</strong>: 严格检查 <code>stderr</code> 是否有任何输出。根据指导书要求，任何 <code>stderr</code> 输出都视为错误</p></li><li><p><strong>结果汇总与报告</strong>:</p><ul><li>收集每个测试的状态 (<code>PASS</code>, <code>FAIL_VALIDATE</code>, <code>FAIL_TIMEOUT</code>, <code>FAIL_JAVA_ERROR</code>, <code>FAIL_STDERR_OUTPUT</code> 等)</li><li>计算通过率，清晰地列出失败的测试点及其主要原因</li><li>对于失败的测试点，<strong>自动保存</strong>其输入数据 (<code>failed_data_...txt</code>) 和详细日志 (<code>failed_stdout_...txt</code>) 到 <code>test_results_hw6</code> 目录。日志中包含：测试信息、stdin、stdout、stderr、以及 <code>validator.py</code> 报告的所有错误信息和 <strong>Traceback (用于调试评测机本身)</strong></li></ul></li><li><p><strong>自动清理</strong>: 测试结束后，自动删除所有临时的子目录。在开始新一轮测试前，也会清理旧的结果目录 <code>test_results_hw6</code></p><p><img src="E:\OO\讨论区帖子\我会构建健壮的多线程电梯评测机\评测结果.png" alt="评测结果"></p></li></ol><h2 id="五、-总结与思考"><a href="#五、-总结与思考" class="headerlink" title="五、 总结与思考"></a>五、 总结与思考</h2><p>这套评测框架旨在通过<strong>自动化、并行化、多阶段数据生成、精细化状态模拟和严格规则校验</strong>，尽可能全面地测试多线程电梯程序的正确性，事实上，两次作业我用这个评测机找到了程序中很多隐蔽的bug，并在互测中成功击落了几个大佬的程序，战绩可查:sunglasses:</p><p><strong>优点</strong>:</p><ul><li><p><strong>自动化程度高</strong>: 一键运行，自动生成数据、执行、判定、报告、清理</p></li><li><p><strong>测试效率高</strong>: 并行执行大大缩短了测试时间，经过舍友的优化，一键脚本支持多个JAR包同时开跑，<del>晚上睡觉前把房间里所有同学的代码都打包好然后狠狠跑他5000组数据</del>，大大提高了评测效率</p><p><img src="E:\OO\讨论区帖子\我会构建健壮的多线程电梯评测机\评测现状.png" alt="评测场景"></p></li><li><p><strong>数据有针对性</strong>: 分阶段生成数据，兼顾了压力和边界情况</p></li><li><p><strong>判定较严格</strong>: 尽可能覆盖了指导书中的显式和隐式规则。</p></li></ul><p><strong>待改进之处</strong>:</p><ul><li><strong>性能分计算</strong>: 当前验证器只计算了性能分的三要素 (<code>T_run</code>, <code>WT</code>, <code>W</code>)，并未实现指导书中复杂的相对评分公式。</li><li><strong>“Quantum Elevator” 检测</strong>: 精确检测<code>电梯空闲状态下收到RECEIVE后未等待0.4s即ARRIVE</code>需要复杂的状态回溯，目前实现是近似的，可能存在少量误判或漏判。</li><li><strong>SCHE 间隔保证</strong>: 数据生成器中对两次 SCHE 间隔的保证是基于一个保守的固定时间估计，而非精确模拟，理论上仍有小概率生成不合规数据（尽管指导书保证输入数据是合理的）。</li><li><strong>验证器复杂度</strong>: <code>validator.py</code> 逻辑复杂，自身也可能存在未发现的 bug。</li></ul><p>总而言之，搭建这样一个评测机本身就是一次很好的面向对象设计和多方面考虑的练习。希望这个思路分享能对大家有所启发，也欢迎交流和指出其中的不足之处！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0_实验报告</title>
      <link href="/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h2><p>执行<code>git status &gt; Untracked.txt</code>，是查询当前<code>README.txt</code>的文件状态，并将其记录在<code>Untracked.txt</code>文件中。后续两个命令同理。</p><p>执行完<code>cat Untracked.txt</code>后，显示出<code>未跟踪的文件</code>，说明文件刚刚新建的时候，其处于未跟踪的状态；执行<code>cat Stage.txt</code>后，显示出<code>要提交的变更</code>，说明修改了文件，并使用<code>add</code>命令之后，文件处于暂存的状态；执行<code>cat Modified.txt</code>之后，显示出<code>尚未暂存以备提交的变更</code>，说明文件再被修改之后，处于被修改状态。</p><h2 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h2><p>add the file 对应的是git中的<code>git add</code>命令</p><p>stage the file 对应的也是git中的<code>git add</code>命令</p><p>commit 对应的是git中的<code>git commit</code>命令</p><h2 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h2><ol><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm --cached hello.txt</code></li></ol><h2 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h2><p>第一次<code>git log</code>如图所示</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片1.png" alt="图片1"></p><p>第二次<code>git log</code>如图所示</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片2.png" alt="图片2"></p><p>第三次<code>git log</code>如图所示</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片3.png" alt="图片3"></p><p>第四次<code>git log</code>如图所示</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片4.png" alt="图片4"></p><h2 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h2><p>执行<code>echo first</code>后如图</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片5.png" alt="图片5"></p><p>执行<code>echo second &gt; output.txt</code>后如图</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片6.png" alt="图片6"></p><p>执行<code>echo third &gt; output.txt</code>后如图</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片7.png" alt="图片7"></p><p>执行<code>echo forth &gt;&gt; output.txt</code>后如图</p><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\图片8.png" alt="图片8"></p><h2 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h2><p><code>command</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash                                                              <span class="built_in">touch</span> <span class="built_in">test</span></span></span><br><span class="line">echo &#x27;echo Shell Start...&#x27; &gt; test</span><br><span class="line">echo &#x27;echo set a = 1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;a=1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set b = 2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;b=2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set c = a+b&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;c=$[$a+$b]&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo c = $c&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save c to ./file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $c&gt;file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save b to ./file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $b&gt;file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save a to ./file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $a&gt;file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file1 file2 file3 to file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file1&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file2&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file3&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file4 to ./result&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file4&gt;&gt;result&#x27; &gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><code>echo echo Shell Start</code>直接把<code>echo Shell Start</code>作为字符串输出；</li><li><code>echo (反顿号)echo Shell Start(反顿号)</code>是将<code>echo Shell Start</code>的<strong>输出</strong>作为外层echo的输入，所以会输出<code>Shell Start</code>；</li><li><code>echo echo $c&gt;file1</code>直接把<code>echo $c&gt;file</code>作为字符串输出；</li><li><code>echo (反顿号)echo $c&gt;file1(反顿号)</code>是将<code>echo $c&gt;file1</code>的<strong>输出</strong>作为外层echo的输入，所以会直接输出<code>$c&gt;file1</code>；</li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p><img src="E:\BlogFile\blog\source_posts\OS-Lab0\实验难点.png" alt="实验难点"></p><p>这里借用一下Hyggge学长的图，我个人认为写的非常好，我在进行线上实验的时候也注意到了这些难点，也是我经常在实验过程中回头去看指导书的地方。</p><p>在我自己的感觉里，我对<code>awk</code>命令和<code>grep</code>命令比较迷惑，也是看了很多攻略。其中<code>grep</code>命令的正则表达式和<code>java</code>的正则表达式不太一样，还得注意。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>对于计算机小白的我来说，刚开始接触命令行还是在大二上研究计组的时候。当初跟着同学里的大佬，在研究自动化测试的时候，慢慢开始接触命令行，学会用命令行解析、比对。当初确实感觉，相对图形化界面，命令行的一个极大的优点就是简洁。</p><p>当然，CLI对于计算机小白的我还是很有挑战性的。在刚开始使用CLI的时候，面对多种多样的指令、参数，我总是记不住它们的功能，写着写着还要重新去翻指导书，后来慢慢的才习惯了。</p><p>道阻且长，行则将至！诸君一起努力！</p><h1 id="原创说明"><a href="#原创说明" class="headerlink" title="原创说明"></a>原创说明</h1><p>本实验报告参考了Hyggge学长的博客，原文章链接如下：<br><a href="https://hyggge.github.io/2022/03/21/os/os-lab0-shi-yan-bao-gao/">https://hyggge.github.io/2022/03/21/os/os-lab0-shi-yan-bao-gao/</a></p><p>另外致谢我的舍友風船同学，在学习过程中给了我很多帮助和解惑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_pre_Logisim</title>
      <link href="/2025/01/18/pre-Logisim/pre-Logisim/"/>
      <url>/2025/01/18/pre-Logisim/pre-Logisim/</url>
      
        <content type="html"><![CDATA[<h1 id="北航计算机组成原理pre阶段Logisim知识分享"><a href="#北航计算机组成原理pre阶段Logisim知识分享" class="headerlink" title="北航计算机组成原理pre阶段Logisim知识分享"></a>北航计算机组成原理pre阶段Logisim知识分享</h1><blockquote><p>通过阅读本文，您大致可以学习到2024年秋季北航计算机组成原理课程pre阶段，关于Logisim知识的内容</p></blockquote><p>Logisim是一个用来仿真模拟电路的软件</p><h2 id="常用部件"><a href="#常用部件" class="headerlink" title="常用部件"></a>常用部件</h2><p>由于篇幅限制，这里不可能精讲所有部件，只是挑选一些笔者认为比较重要的部件进行介绍</p><h3 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h3><p>又叫分线器。一般是用来把一条有多比特位数据的数据线分开成不同的几小条数据线，或者是把几条线的比特位合并到一条数据线中。在将来的CPU设计中，Splitter还经常用于从一个多位数据线上截取特定比特位，送给不同的部件</p><p>举个栗子</p><p><img src="/image.png"></p><p>图中的<code>Splitter A</code>，把一个32位的数据分成了四份，每一份都是8位，而<code>Splitter B</code>，只取了32位数据的低20位。<code>Splitter C</code>则是把32位输入的低8位作为合并数据的低8位，把32位输入的低20位作为高20位，合并成了一个28位的输出</p><p>Logisim的左下角有这个部件的属性</p><ul><li><code>Fan Out</code> : 表示该<code>Splitter</code>有几个分支，即将数据分成了几路，或者将几路数据合并了</li><li><code>Bit Width In</code> : 表示总线的位宽，也就是图中<code>Splitter A</code>左下角的引脚所连线的位宽</li><li><code>Appearance</code> : 选择<code>Splitter</code>的外貌，是左手手性还是右手手性等</li><li><code>Bit 0-31</code> : 决定总线中的某一位，是否在某一个分支中</li></ul><h3 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h3><p>又叫引脚。常见的有输入引脚和输出引脚。还有是否支持三态，即<code>0</code>, <code>1</code>, <code>x</code>（浮空值）</p><p>与引脚有关的还有上拉电阻和下拉电阻，这个主要用来处理来自父级电路的浮空值，把浮空值转换成0（下拉）或者是1（上拉）</p><h3 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h3><p>探针，用来显示一条数据线的数据，不会影响电路的工作，<del>debug的时候很好用</del></p><h3 id="Tunnel"><a href="#Tunnel" class="headerlink" title="Tunnel"></a>Tunnel</h3><p>一对同名的<code>Tunnel</code>本质上和一条导线是一样的。<code>Tunnel</code>可以让你的电路更加清晰，不会有那么多<del>丑陋的导线</del>，错综复杂</p><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>时钟。在时序电路里很重要</p><p>时钟会以一定的频率在高电平和低电平之间转换。转换的瞬间统称时钟沿。由低电平转换到高电平称作上升沿，由高电平转换到低电平称作下降沿</p><h3 id="Gates"><a href="#Gates" class="headerlink" title="Gates"></a>Gates</h3><p>各种门元件。这里不做一一介绍了</p><h3 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a>MUX</h3><p>多路选择器。在一个元件内，一个输出可能有多个信息来源，在这些信息中筛选出我们需要的数据，就要用到MUX</p><p><code>MUX</code>包括输入信号和选择信号，每一个输入信号对应一个2进制编码。还可以根据需要，增加使能端：若使能端为1或浮空值，<code>MUX</code>均可以正常工作；若为0，则输出为浮空值。</p><h3 id="DMX"><a href="#DMX" class="headerlink" title="DMX"></a>DMX</h3><p>多路复用器。其功能与<code>MUX</code>正好相反</p><p><code>DMX</code>将一个输入，按照需求，送到不同的输出上。相较于<code>MUX</code>，<code>DMX</code>还支持三态。如果支持三态，则未被选择的输出引脚会输出浮空值而不是0</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>解码器。解码器的输入只有选择信号。它和<code>DMX</code>长得很像，对于一个特定的选择信号，解码器对应的输出引脚会输出1</p><p>常见于选择写入的使能，在P0的寄存器堆实现中会用到</p><h3 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h3><p>运算元件，包括加减乘除、取负数、比较、移位、位加等，比较好理解，这里不做过多介绍</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>寄存器。寄存器内部会利用触发器等来存储一个值，一般是在时序电路中会被用到，常见的触发模式是时钟上升沿存入</p><p>若复位信号不为1，则当时钟上升沿到来时，寄存器会将写入端口收到的数据写入寄存器内部，相应的输出会改变。寄存器的输出就是寄存器内部存着的数据</p><p><img src="/image-1.png" alt="alt text"></p><p>图中，寄存器左侧的D引脚便是输入端口，en引脚是写使能，有一个三角形的引脚是时钟引脚，0是复位端口，当该输入为1是，无论时钟处于高电平还是低电平，直接将寄存器中存储的值变成0</p><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p><code>RAM</code>是可读可写的存储器，一般我们用它来作为CPU的内存</p><p><code>RAM</code>有多种数据传输方式，比较常用的是读写分别用各自的端口</p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p><code>RAM</code>是只读的，一般我们用它来存储CPU需要运行的指令</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>计数器。它长得和寄存器很像。以上升沿为例，若复位信号不为1，则每个时钟上升沿到来时，计数器会把它内部的数据+1</p><p>根据需求，当计数器内部的值到达最大值时，有几个不同的工作模式：</p><ul><li><code>Wrap Around</code> : 变成0重新计数</li><li><code>Continue Counting</code> : 继续计数</li><li><code>Stay At Value</code> : 保持于最大值或最小值</li><li><code>Load Next Value</code> : 从D端读入下一个数据</li></ul><h2 id="常见电路"><a href="#常见电路" class="headerlink" title="常见电路"></a>常见电路</h2><h3 id="寄存器的同步复位"><a href="#寄存器的同步复位" class="headerlink" title="寄存器的同步复位"></a>寄存器的同步复位</h3><p>寄存器本身是支持异步复位的，但是我们很多时候需要同步复位，也就是当时钟上升沿到来时，若复位信号为1，将寄存器复位</p><p>其实方法有很多，我们讲解一种比较清楚、比较容易看懂的做法</p><p>说白了，同步复位的要求，就是当时钟上升沿到来时，根据<code>reset</code>信号的值，决定我们要向寄存器里写什么值，因此我们需要用到<code>MUX</code>来实现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2025/01/17/2024-1-17/"/>
      <url>/2025/01/17/2024-1-17/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>你好，当你看到这段文字的时候，证明我已经成功搭建出了自己的blog，真是<del>十分甚至九分</del>的感动口牙！<br>今后我也会多多在这个blog上分享自己的学习心得、游戏心得、生活琐事等等！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e1cda6,      #d8b75d,      #66afd4,      #6d6df0,      #db92d5    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    animation: Gradient 10s ease infinite !important;  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(222, 143, 234);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;  }    #cursor.hidden {    opacity: 0;  }    #cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);  }    #cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);  }  :root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);  }    /* 文章页、归档页、普通页面 */  div#post,  div#page,  div#archive {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;  }    /* 导航栏 */  #page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);  }    [data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;  }    /* 夜间模式遮罩 */  [data-theme="dark"] #recent-posts > .recent-post-item,  [data-theme="dark"] #aside-content .card-widget,  [data-theme="dark"] div#post,  [data-theme="dark"] div#archive,  [data-theme="dark"] div#page {    background: var(--trans-dark);  }      /* 夜间模式页脚页头遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }    /* 阅读模式 */  .read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;  }  .read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;  }    /* 夜间模式下的阅读模式 */  [data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  [data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  .pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 4px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 7rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden}.pace-inactive .pace-progress {    opacity: 0;    transition: .3s ease-in}.pace .pace-progress {    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    /* linear-gradient(to right, #3494e6, #ec6ead) */    background: linear-gradient(to right, #43cea2, #3866ca);    animation: gradient 2s ease infinite;    background-size: 200%}.pace.pace-inactive {    opacity: 0;    transition: .3s;    top: -8px}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  animation: ccc 5s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@keyframes ccc {  0% {    transform: rotate(0deg);  }  to {    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #4953da;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #ea73f8;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ac3fff;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #55f8e0;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #27a20b;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #b1ad77;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: #0080ff;}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: #0080ff;  animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' fill='%23F2A3FE' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/snow.js"/>
      <url>/js/snow.js</url>
      
        <content type="html"><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    // 移动端不显示} else {    document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');    window && (() => {        let e = {            flakeCount: 50, // 雪花数目            minDist: 150,   // 最小距离            color: "255, 255, 255", // 雪花颜色            size: 1.5,  // 雪花大小            speed: .5,  // 雪花速度            opacity: .7,    // 雪花透明度            stepsize: .5    // 步距        };        const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {            window.setTimeout(e, 1e3 / 60)        }            ;        window.requestAnimationFrame = t;        const i = document.getElementById("snow"),            n = i.getContext("2d"),            o = e.flakeCount;        let a = -100,            d = -100,            s = [];        i.width = window.innerWidth,            i.height = window.innerHeight;        const h = () => {            n.clearRect(0, 0, i.width, i.height);            const r = e.minDist;            for (let t = 0; t < o; t++) {                let o = s[t];                const h = a,                    w = d,                    m = o.x,                    c = o.y,                    p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));                if (p < r) {                    const e = (h - m) / p,                        t = (w - c) / p,                        i = r / (p * p) / 2;                    o.velX -= i * e,                        o.velY -= i * t                } else                    o.velX *= .98,                        o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),                        o.velX += Math.cos(o.step += .05) * o.stepSize;                n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",                    o.y += o.velY,                    o.x += o.velX,                    (o.y >= i.height || o.y <= 0) && l(o),                    (o.x >= i.width || o.x <= 0) && l(o),                    n.beginPath(),                    n.arc(o.x, o.y, o.size, 0, 2 * Math.PI),                    n.fill()            }            t(h)        }            , l = e => {                e.x = Math.floor(Math.random() * i.width),                    e.y = 0,                    e.size = 3 * Math.random() + 2,                    e.speed = 1 * Math.random() + .5,                    e.velY = e.speed,                    e.velX = 0,                    e.opacity = .5 * Math.random() + .3            }            ;        document.addEventListener("mousemove", (e => {            a = e.clientX,                d = e.clientY        }        )),            window.addEventListener("resize", (() => {                i.width = window.innerWidth,                    i.height = window.innerHeight            }            )),            (() => {                for (let t = 0; t < o; t++) {                    const t = Math.floor(Math.random() * i.width)                        , n = Math.floor(Math.random() * i.height)                        , o = 3 * Math.random() + e.size                        , a = 1 * Math.random() + e.speed                        , d = .5 * Math.random() + e.opacity;                    s.push({                        speed: a,                        velX: 0,                        velY: a,                        x: t,                        y: n,                        size: o,                        stepSize: Math.random() / 30 * e.stepsize,                        step: 0,                        angle: 180,                        opacity: d                    })                }                h()            }            )()    }    )();}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = '見て見て!!!';    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = 'Timotei————';    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
