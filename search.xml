<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA_OS_Lab5_实验报告</title>
      <link href="/2025/05/30/OS-Lab5/BUAA-OS-Lab5%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/05/30/OS-Lab5/BUAA-OS-Lab5%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab5-实验报告"><a href="#BUAA-OS-Lab5-实验报告" class="headerlink" title="BUAA-OS-Lab5 实验报告"></a>BUAA-OS-Lab5 实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><blockquote><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p></blockquote><p>当外部设备产生中断信号或者更新数据时，此时Cache中之前旧的数据可能刚完成缓存，那么完成缓存的这一部分无法完成更新，则会发生错误的行为。<br>缓存机制的设计是为了提高效率，让数据发生改变的时候不立即写入内存，而是等Cache发生替换的时候才写进去。<br>而对于串口设备这种读写频繁、实时交互的设备来说，如果写入 kseg0 部分，数据可能很久都不被真正写入内存中，引发错误。在相同的时间内，发生读写错误的概率远高于IDE磁盘。</p><h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p></blockquote><ul><li>一个磁盘块的大小为<strong>4KB</strong>，一个文件控制块的大小为<strong>256B</strong>，一个磁盘块中最多有<strong>16个</strong>文件控制块。</li><li>一个目录大小为<strong>4KB</strong>，所以一个目录下<strong>最多有1024个</strong>目录项，也就是最多可以指向<strong>1024个</strong>磁盘块。每一个磁盘块有最多有<strong>16</strong>个文件控制块，所以一个目录最多有<strong>16K个</strong>文件。</li><li>一个文件有<strong>直接指针</strong>+<strong>间接指针</strong>共1024个。每个指针指向一个磁盘块，存储着该文件的一部分文件数据。所以文件系统支持的单个文件最大为<strong>4MB</strong></li></ul><h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure><p>由代码可知最大磁盘大小为1GB。</p><h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><blockquote><p>在本实验中， fs&#x2F;serv.h、 user&#x2F;include&#x2F;fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure><p><code>user/include/fs.h</code>里面，这两个宏分别用来找<code>fd</code>对应的<strong>文件信息页面</strong>和<strong>文件的缓存区地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BLOCK_SIZE / SECT_SIZE) <span class="comment">/* sectors to a block */</span></span></span><br></pre></td></tr></table></figure><p>可以实现 sect 号到 block 号的转换。</p><h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</p></blockquote><p>会共享</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/testfork&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>((r = fork()) == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">    n = read(fd, buf, <span class="number">3</span>);</span><br><span class="line">    debugf(<span class="string">&quot;child : %s\n&quot;</span>, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程</span></span><br><span class="line">    n = read(fd, buf, <span class="number">3</span>);</span><br><span class="line">    debugf(<span class="string">&quot;father : %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件<code>/testfork</code>种的内容为<code>abcdef</code></p><p>而输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child : abc</span><br><span class="line">father : def</span><br></pre></td></tr></table></figure><p>所以文件指针和文件描述符是会共享的</p><h3 id="Thinking-5-5-1"><a href="#Thinking-5-5-1" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File结构体表示一个文件或目录的元数据，既存在于磁盘上的物理结构，也存在于文件系统服务进程的内存中。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名或目录名</span></span><br><span class="line">    <span class="type">uint32_t</span> f_size;         <span class="comment">// 文件或目录占据的存储空间大小，以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> f_type;         <span class="comment">// 文件的类型标识，区分文件和目录</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// 直接指针数组，指向包含文件内容的磁盘块地址</span></span><br><span class="line">    <span class="type">uint32_t</span> f_indirect;     <span class="comment">// 间接指针，指向一个磁盘块，该磁盘块存储了指向文件内容的其他磁盘块地址</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>      <span class="comment">// 指向该文件所属目录的指针，此字段仅在内存中表示有效</span></span><br><span class="line">    <span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)]; <span class="comment">// 用于字节对齐的填充字段，确保结构体大小为256字节</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fd结构体代表一个文件描述符，它存储在内存中，包含了关于文件操作的上下文信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    u_int fd_dev_id; <span class="comment">// 设备标识符，用于识别文件所属的外设类型</span></span><br><span class="line">    u_int fd_offset; <span class="comment">// 文件偏移量，表示当前文件操作的读写位置</span></span><br><span class="line">    u_int fd_omode;  <span class="comment">// 文件打开模式，指定了文件的操作权限，如读写、只读、只写等</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filefd结构体结合了文件描述符和文件元数据，提供了对文件操作的完整上下文。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span>       <span class="comment">// 文件描述符，包含设备ID、偏移量和打开模式</span></span><br><span class="line">    u_int f_fileid;       <span class="comment">// 文件标识符，用于唯一标识一个文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span>   <span class="comment">// 文件元数据，包含了文件名、大小、类型等属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><blockquote><p>下图（文件系统服务时序图）中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><p>在图5.7中，我们可以观察到两种不同类型的箭头，分别是实心箭头和虚线箭头。实心箭头用于表示同步消息，而虚线箭头则表示返回消息。</p><p>init 进程创建了<code>fs</code>和<code>user</code>两个进程。用户进程和文件系统之间的箭头表明二者之间存在交互，用户进程发出需求，文件系统实现。</p><p>通信的基本流程如下：首先，用户空间调用<code>user/lib/file.c</code>中提供的文件操作函数，如<code>open</code>。这些函数随后调用<code>user/lib/fsipc.c</code>的函数。传递所需的操作类型码，并进行<code>ipc_send</code>，向文件系统发送请求，并用<code>ipc_rcv</code>来接收结果。</p><p>文件系统接收到请求后，使用<code>serv.c</code>中的函数来处理请求。处理结束后，再次调用<code>ipc_send</code>把结果传给用户进程，用户进程继续运行。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><p>本次实验中需要填补的内容并不是很多，难度并不算大，但是MOS的文件系统本身比较复杂，里面错综复杂的调用关系需要理清楚才行。文件系统中有很多非常长的文件，这些文件本身内部的函数比较多比较复杂，需要对里面的内容进行一个比较清楚的把握。</p><p>这些函数调用其实都是实现文件系统的一系列操作，本质上都是一样的，只不过调用是一层一层向里面调用的。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab5的上机倒是挺煎熬的。exam因为理解的不够到位，导致卡了好久，最后在助教的帮助下才过了，extra简单的看了看，很复杂，不过有一个整体的思路，里面还有很多很多细节。</p><p>OS的上机到这就结束了。这种上机节奏感觉还是很不错的，课下的任务给足了提示和解释，简单浏览代码就可以完成；上机要求对代码的整体架构有一个清晰的把握，需要稍微深入地阅读有关的代码。这种方式其实挺好，确保了我们每周都会花一定的时间来浏览整个代码，所以最后对MOS的内部逻辑还是了解的挺好的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit3_单元总结</title>
      <link href="/2025/05/18/OO-Unit3%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
      <url>/2025/05/18/OO-Unit3%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第三单元总结"><a href="#「BUAA-OO」第三单元总结" class="headerlink" title="「BUAA OO」第三单元总结"></a>「BUAA OO」第三单元总结</h1><h2 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h2><p>本次面向对象编程第三单元的主题是：「BUAA OO」第三单元总结</p><ul><li>第九次作业：根据 JML 规格实现<code>Person</code>类、<code>Tag</code>类、<code>Network</code>类</li><li>第十次作业：根据 JML 规格实现<code>OfficialAccount</code>类</li><li>第十一次作业：根据 JML 规格实现<code>Message</code>类及其3个子类</li></ul><h2 id="三次迭代说明"><a href="#三次迭代说明" class="headerlink" title="三次迭代说明"></a>三次迭代说明</h2><h3 id="第九次作业"><a href="#第九次作业" class="headerlink" title="第九次作业"></a>第九次作业</h3><p>本次作业主要是根据JML规格实现三个接口中的所有方法，按照JML规格严格实现理论上就是正确的，所以其实要多注意细节；但是完全按照JML实现显然是不行的，<del>哈哈tle了吧</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ ensures \result ==</span></span><br><span class="line"><span class="comment">      @         (\sum int i; 0 &lt;= i &amp;&amp; i &lt; persons.length;</span></span><br><span class="line"><span class="comment">      @             (\sum int j; i &lt; j &amp;&amp; j &lt; persons.length;</span></span><br><span class="line"><span class="comment">      @                 (\sum int k; j &lt; k &amp;&amp; k &lt; persons.length</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[i].getId()).isLinked(getPerson(persons[j].getId()))</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[j].getId()).isLinked(getPerson(persons[k].getId()))</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[k].getId()).isLinked(getPerson(persons[i].getId()));</span></span><br><span class="line"><span class="comment">      @                     1)));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryTripleSum</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>比较典型的就是这个，按照JML里面写三重循环显然是会寄的，所以要想别的方法。</p><p><del>经过和ai的讨论</del>，笔者发现其实可以用动态维护的方法。也就是说，先把这个值初始化成0，然后每次<code>addRelation</code>或者<code>modifyRelation</code>或者等等时，按照要求更新值的大小。这样其实是把算法的压力分配到了加减关系上面了，而且这样做耗时短，同时也避免了冗余的计算，<del>比如哪个坏蛋给你卡好几次<code>qts</code>这你不炸了吗</del>。</p><p>除此之外，别的优化笔者倒是没怎么做。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_ninth.png" alt="第9次作业类图"></p><p>整体架构图如上所示，除了题目要求的类笔者并没有新增别的类。</p><h4 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_ninth.png" alt="第9次作业代码复杂度"></p><p>这次作业的整体复杂度不算特别高。比较高的<code>Network</code>类里面是在维护查询的数据。</p><h4 id="Junit测试感悟"><a href="#Junit测试感悟" class="headerlink" title="Junit测试感悟"></a>Junit测试感悟</h4><p>Junit的测试一开始有一个点一直卡着过不去，经过仔细阅读指导书后发现是<code>pure</code>测试的关键。一个方法是<code>pure</code>的，关键就在于在它调用前后，对象的属性不应当发生改变。所以，测试<code>pure</code>的关键就在于在调用该方法之前，将其要操作的对象深拷贝，然后和它调用后的对象进行比较。<del>当然有个更直白的方法就是直接新建两个属性一样的实例，其中某个作为对照组来测试，管它什么拷贝</del></p><h3 id="第十次作业"><a href="#第十次作业" class="headerlink" title="第十次作业"></a>第十次作业</h3><p>本次作业新增了一个<code>OfficialAccount</code>类，另外，原先的类里面也有一些新的迭代内容。</p><p>本次强测tle了好几个点，<del>五一玩的太嗨了</del>，没有做细致的优化。比较卡时间的就是这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(personId) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          getPerson(personId).containsTag(tagId);</span></span><br><span class="line"><span class="comment">      @ ensures \result == getPerson(personId).getTag(tagId).getValueSum();</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) !containsPerson(personId);</span></span><br><span class="line"><span class="comment">      @ signals (TagIdNotFoundException e) containsPerson(personId) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                    !getPerson(personId).containsTag(tagId);</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryTagValueSum</span><span class="params">(<span class="type">int</span> personId, <span class="type">int</span> tagId)</span> <span class="keyword">throws</span> PersonIdNotFoundException, TagIdNotFoundException;</span><br></pre></td></tr></table></figure><p>这个其实跟前一次作业还是一样的，做好动态规划就好了，并不是什么复杂的问题。当然这个要做动态规划的话还要注意一些深层次的细节。笔者在完成了动态规划之后还有一些细节上的bug，处理了很久。在第十一次作业的自测过程中，与这个方法有关还出了一个非常细小的bug，这个之后再说。</p><p>在互测过程中，笔者也针对性的设计了一些和<code>qtvs</code>有关的测试数据，成功hack到了房友。</p><p>另外，在进行了上述优化之后，所有强测点，笔者最慢的在本地用profiler分析，也能压缩到1600ms以内，但是评测机跑下来就是tle，<del>真该加强一下这个烂评测机了</del>。所以笔者在仔细考虑之后，将这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(id1) &amp;&amp; id1 == id2 ;</span></span><br><span class="line"><span class="comment">      @ ensures \result==0 ;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          containsPerson(id2) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          id1 != id2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\exists PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @          path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[path.length - 1].equals(getPerson(id2));</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i])));</span></span><br><span class="line"><span class="comment">      @ ensures  (\exists PersonInterface[] pathM;</span></span><br><span class="line"><span class="comment">      @          pathM.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          pathM[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          pathM[pathM.length - 1].equals(getPerson(id2)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; pathM.length; pathM[i - 1].isLinked(pathM[i]));</span></span><br><span class="line"><span class="comment">      @          (\forall PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @          path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[path.length - 1].equals(getPerson(id2)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i]));</span></span><br><span class="line"><span class="comment">      @          (\sum int i; 0 &lt;= i &amp;&amp; i &lt; path.length; 1) &gt;=</span></span><br><span class="line"><span class="comment">      @          (\sum int i; 0 &lt;= i &amp;&amp; i &lt; pathM.length; 1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          \result==(\sum int i; 1 &lt;= i &amp;&amp; i &lt; pathM.length; 1));</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) !containsPerson(id1);</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                       !containsPerson(id2);</span></span><br><span class="line"><span class="comment">      @ signals (PathNotFoundException e) containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                   containsPerson(id2) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         !(\exists PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @         path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         path[path.length - 1].equals(getPerson(id2));</span></span><br><span class="line"><span class="comment">      @         (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i])));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryShortestPath</span><span class="params">(<span class="type">int</span> id1,<span class="type">int</span> id2)</span> <span class="keyword">throws</span> PersonIdNotFoundException, PathNotFoundException;</span><br></pre></td></tr></table></figure><p>由常规的BFS算法，即广度优先算法，优化成了双向BFS算法。至此之后，最慢的点也能在500ms就能跑完了。</p><p>双向 bfs，或说图的双向搜索算法，是对于广度优先搜索算法的一种改进。bfs 从起点开始由浅入深地遍历，直到找到终点；而双向 bfs 则从起点与终点同时开始遍历，直到遍历的区域相交（说明找到了最短路径）。</p><h4 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_tenth.png" alt="第10次作业类图"></p><h4 id="代码复杂度分析-1"><a href="#代码复杂度分析-1" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_tenth.png" alt="第10次作业代码复杂度"></p><p>本次作业复杂度整体就有点高了，主要集中在<code>Network</code>类，因为其中包含了<code>queryShortestPath</code>方法和<code>modifyRelation</code>方法。</p><h3 id="第十一次作业"><a href="#第十一次作业" class="headerlink" title="第十一次作业"></a>第十一次作业</h3><p>这次作业主要新增了<code>Message</code>类以及它的三个子类。</p><p>本次作业值得注意的点倒是不算多，笔者个人认为只有一个：在第十一次作业里面，<code>sendMessage</code>的加入，可能使得相同的文章可能会被转发到一个人的容器中。在删除的时候，需要将所有该id的文章都删掉。</p><p>另外，在自行测试的时候，笔者发现了一个非常隐蔽的bug。因为<code>Tag</code>是允许id相同但是实例不同的。也就是说，两个<code>person</code>，他们各自拥有一个<code>tag</code>，这两个<code>tag</code>显然实例是不同的，但是他们可以拥有相同的id。在笔者的实现中，当发生了<code>modifyRelation</code>的时候，需要找到同时包含这两个<code>person</code>的<code>tag</code>，因此笔者采用了一个<code>HashMap</code>来记录这个人所在的<code>tag</code>，而key便是使用了<code>tag</code>的id。然而，一个人可能同时处于id相同的不同<code>tag</code>里面，<code>HashMap</code>的key一定是唯一的，所以用<code>HashMap</code>来记录必然是错误的。</p><p>笔者在与小伙伴们讨论之后，采用了这样一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TagKey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ownerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> tagId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TagKey</span><span class="params">(<span class="type">int</span> ownerId, <span class="type">int</span> tagId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ownerId = ownerId;</span><br><span class="line">        <span class="built_in">this</span>.tagId = tagId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="type">TagKey</span> <span class="variable">tagKey</span> <span class="operator">=</span> (TagKey) o;</span><br><span class="line">        <span class="keyword">return</span> ownerId == tagKey.ownerId &amp;&amp; tagId == tagKey.tagId; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(ownerId, tagId); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这样的一种数据结构来记录<code>tag</code>的“唯一id”，这样就确保了key是唯一的</p><h4 id="架构图-2"><a href="#架构图-2" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_eleventh.png" alt="第11次作业类图"></p><h4 id="代码复杂度分析-2"><a href="#代码复杂度分析-2" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_eleventh.png" alt="第11次代码复杂度"></p><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="测试思想"><a href="#测试思想" class="headerlink" title="测试思想"></a>测试思想</h3><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><blockquote><p>黑盒测试，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。<br>——百度百科，黑盒测试</p></blockquote><p>评测机其实就是一种黑盒测试，它只关心程序是否能产生正确的输出，不关心程序内部是如何运作的。</p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><blockquote><p>白盒测试是一种测试用例设计方法，盒子指的是被测试的软件，白盒指的是盒子是可视的，即清楚盒子内部的东西以及里面是如何运作的。“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。<br>——百度百科，白盒测试</p></blockquote><p>本单元要求学生设计的 Junit 测试便是一种白盒测试，它要求被测方法的行为完全符合规格说明，不能产生越界的行为。</p><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试是针对程序模块来进行正确性检验的测试工作。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法。单元测试的目标是隔离程序部件并证明这些单个部件是正确的。</p><p>本单元的Junit就是一种单元测试。</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><blockquote><p>功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。功能测试也叫数据驱动测试，只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码。<br>——百度百科，功能测试</p></blockquote><p>功能测试其实就是一种黑盒测试。</p><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><blockquote><p>集成测试，即对程序模块采用一次性或增值方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。该测试，可以由程序员或是软件品保工程师进行。<br>——Wikipedia，集成测试</p></blockquote><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>压力测试，顾名思义就是针对特定的系统、组件、程序等，采用超过正常使用条件下的情况进行运转，确认在极限状态下，程序是否能够正常运转。</p><p>到目前笔者还没用使用过这种测试方式，但似乎航空航天设计经常会使用这种测试方法（确认系统在什么条件下会损坏，以及安全使用条件）。</p><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><blockquote><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。<br>——百度百科，回归测试</p></blockquote><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><p>本次笔者只写了一个简易的数据生成器，规范了生成数据的合法性以后，手动添加了一些条件来增加数据的强度。生成数据时应当优先考虑JML规格中描述的每一个方法的behavior。由于时间有限，并没有刻意去构造足够强大的测试数据。因此笔者的数据生成器主要在本地测试时发挥了作用，在互测阶段成功刀中了几个人。</p><h2 id="如何引导大模型在不同场景下完成复杂任务"><a href="#如何引导大模型在不同场景下完成复杂任务" class="headerlink" title="如何引导大模型在不同场景下完成复杂任务"></a>如何引导大模型在不同场景下完成复杂任务</h2><p>现在的大模型整体可用性非常高，一般来讲不用刻意去多步引导。笔者尝试过直接使用大模型完成第十一次作业，其完成的比较完善，性能方面有所欠缺，<del>代码风格惨不忍睹</del>，但其他方面确实很优异，笔者只进行了细节上的优化与维护和性能上的改善。</p><h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><p>契约式设计是一种设计计算机软件的方法。这种方法要求软件设计者为软件组件定义正式的，精确的并且可验证的接口。</p><p>契约式设计的核心在于分离规格设计与代码实现。设计者通过需求来设计与撰写每个方法的规格，程序员通过规格来实现代码。这种设计思想可以有效减少代码中的bug数量，提高代码的可靠性与可维护性；但由于契约式设计需要为每个类书写详细的契约（契约长度往往会超过代码本身的长度），这种设计方式会显著地降低开发的速度。因此在实际应用中往往在设计代码的核心模块中使用，以保证核心模块的正确性。</p><p>JML是一门非常冷门的规格建模语言，课程组并未让学生们完成由需求设计规格这一层次，而是将三次迭代的重点放在了由规格实现代码。基于规格的层次化设计有两个层次，一是根据需求设计规格，二是根据规格实现代码。课程组将绝大部分重心都放到了后者之上，笔者认为不是很合理。可以尝试让同学们自己编写JML规格。</p><h2 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h2><p>Junit测试是由规格设计引来的测试，旨在验证代码是否符合规格说明书。想要进行Junit测试，前提是拥有一个完全正确的规格，否则Junit测试完全是一纸空谈。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>本次Junit测试我并没有考虑随机数据构造，只是选择了15-30个有特色的数据点进行测试充分覆盖JML规格中各个<code>behavior</code>的<code>requires</code>和<code>ensures</code>。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>深度检査JML规格中<code>not_assigned</code>的属性，保存一份方法执行前的深拷贝，保证各个属性未发生变化。逐行检查<code>requires</code>和<code>ensures</code>。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本单元的学习，笔者大致学习到规格化设计的步骤，体会到规格化设计的优点。本单元对于Junit的学习，让我理解了Junit的使用方法与其存在的意义。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab4_实验报告</title>
      <link href="/2025/05/09/OS-Lab4/BUAA_OS_Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/05/09/OS-Lab4/BUAA_OS_Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab4-实验报告"><a href="#BUAA-OS-Lab4-实验报告" class="headerlink" title="BUAA_OS_Lab4_实验报告"></a>BUAA_OS_Lab4_实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><blockquote><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 <code>msyscall</code>留下的信息吗？</li><li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 <code>msyscall</code> 时同样的参数的？</li><li>内核处理系统调用的过程对 <code>Trapframe</code> 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul></blockquote><ul><li>内核在保护现场的时候会调用<code>SAVE_ALL</code>宏，把通用寄存器的<code>sp</code>复制到<code>$k0</code>中。保存现场需要使用<code>$v0</code>作为协寄存器到内存的中转寄存器，写到内存时需要<code>sp</code>，所以在正式保存协寄存器和通用寄存器前先保存这两个寄存器。</li><li>可以的。因为内核在陷入内核、保存现场的过程中，寄存器 a0-a3 中的值都没有被破坏。用户在调用 msyscall 时，传入的参数会被保存在 a0-a3 寄存器和堆栈中。当陷入内核时，a0-a3 寄存器不会被破坏，并且会将用户栈中的相应参数复制取出到内核栈中。因此，<code>sys_*</code> 函数可以从寄存器和用户栈处获得用户调用 msyscall 时传入的参数值。</li><li>更改了 epc 的值（+4），使得返回用户态后能够正常执行下一条指令；返回值会被存储到 v0 寄存器内，使得返回用户态后可以获取调用后的返回值。</li></ul><h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><blockquote><p>思考 <code>envid2env</code> 函数: 为什么 <code>envid2env</code> 中需要判断 <code>e-&gt;env_id != envid</code> 的情况？如果没有这步判断会发生什么情况？</p></blockquote><p>我们在试图通过 <code>envid</code> 来获取对应的进程控制块时，只取了 <code>envid</code> 的后 10 位来作为数组下标。但要确保 <code>envid</code> 和取出的进程块<strong>完全对应</strong>，所以我们仅仅看后 10 位是不够的。用 <code>e-&gt;env_id != envid</code> 这一步来确定传入的 <code>envid</code> 确实和取出的进程块是对应的。如果不判断envid是否相同，会取到错误的或者本该被销毁的进程控制块。</p><h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><blockquote><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 <em>kern&#x2F;env.c</em> 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 <code>0</code>，请结合系统调用和 <em>IPC</em> 部分的实现与<code>envid2env()</code> 函数的行为进行解释。</p></blockquote><p>在系统调用和 ipc 通讯的相关函数里，我们如果传入的 <code>envid</code> 为 0，那么代表相应的进程为 <strong>当前进程</strong>。因此，需要保证每一个进程块的 <code>envid</code> 不为 0，才能让这个标准正确实现。</p><h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><blockquote><p>关于 <code>fork</code> 函数的两个返回值，下面说法正确的是：<br>A、 <code>fork</code> 在父进程中被调用两次，产生两个返回值<br>B、 <code>fork</code> 在两个进程中分别被调用一次，产生两个不同的返回值<br>C、 <code>fork</code> 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>D、 <code>fork</code> 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p></blockquote><p>C</p><h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><blockquote><p>我们并不应该对所有的用户空间页都使用 <code>duppage</code> 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 <em>kern&#x2F;env.c</em> 中 <code>env_init</code> 函数进行的页面映射、 <em>include&#x2F;mmu.h</em> 里的内存布局图以及本章的后续描述进行思考。</p></blockquote><ul><li>在 0 - <code>USTACKTOP</code> 范围的内存需要使用 <code>duppage</code> 进行映射;</li><li><code>USTACKTOP</code> 到 <code>UTOP</code> 之间的 <strong>user exception stack</strong> 是用来进行页写入异常的，不会在处理COW异常时调用 <code>fork()</code> ,所以 <code>user exception stack</code> 这一页不需要共享；</li><li><code>UTOP</code>以上页面的<strong>内存与页表</strong>是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的<code>duppage</code>；</li><li>其上范围的内存要么<strong>属于内核</strong>，要么是所有用户进程<strong>共享的空间</strong>，用户模式下只可以读取。除只读、共享的页面外都需要设置 <code>PTE_COW</code> 进行保护。</li></ul><h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><blockquote><p>在遍历地址空间存取页表项时你需要使用到 <code>vpd</code> 和 <code>vpt</code> 这两个指针，请参考 <em>user&#x2F;include&#x2F;lib.h</em> 中的相关定义，思考并回答这几个问题：</p><ul><li>vpt 和 vpd 的作用是什么？怎样使用它们？</li><li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种方式来修改自己的页表项吗？</li></ul></blockquote><ol><li><code>vpt</code> 和 <code>vpd</code> 分别是指向用户页表和用户页目录的指针。它们用于访问和遍历进程的地址空间中的页表项。以 <code>vpt</code> 为例，要获取当前虚拟地址 <code>va</code> 所对应的页表项，可以使用 <code>vpt[VPN(va)]</code>，使用宏 <code>VPN(va)</code> 获取虚拟地址 <code>va</code> 对应的页面的编号，即相对 <code>(*vpt)</code> 的偏移量，通过这个偏移量就可以得到对应的页表项。</li><li>存储页表的空间属于用户空间，因此用户进程可以通过指针取得页表的地址来进行访问。系统是线性地进行页面的映射，因此可以很方便地实现“虚拟地址-&gt;虚拟页号”的转变。虚拟页号即虚拟地址对应的虚拟页面相对页表项的偏移量，获得了页表首地址和偏移量后，就可以获取对应的页表项。</li><li><code>vpd</code> 的值为 <code>(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT))</code>，在<code>UVPT</code>和<code>UVPT + PDMAP</code>之间，说明将页目录映射到了某一页表位置；通过 <code>vpt</code> 来找 <code>vpd</code>，这表明页表 <code>vpt</code> 中存在某一页为页目录，由此体现了自映射设计。</li><li>不能，该区域对用户<strong>只读不写</strong>，用户进程只能读取页表项，不能进行修改。想要修改需要陷入内核</li></ol><h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><blockquote><p>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 <code>Trapframe</code>运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</li><li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></blockquote><p>出现 COW 异常时，也即进程尝试写 COW 页面时，会出现这样的异常重入。</p><p>异常处理完毕之后，恢复现场的工作会在用户态进行，因此需要把 tf 保存在用户态的栈空间下。</p><h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><blockquote><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？</p></blockquote><ul><li>解放内核，不用内核执行大量的页面拷贝工作；</li><li>可以减少内核态和用户态之间的切换次数，从而提高异常处理的效率；</li><li>内核态处理失误产生的影响较大，可能会使得操作系统崩溃；</li><li>用户状态下不能得到一些在内核状态才有的权限，避免改变不必要的内存空间。</li></ul><h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><blockquote><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul></blockquote><p>确保在子进程创建过程中，页表项的修改能够被正确地加载到 TLB 中。如果不这样做，可能会导致在子进程创建过程中需要访问的页表项尚未被加载到 TLB 中，从而影响子进程的正常创建和运行。</p><h2 id="实验难点分析"><a href="#实验难点分析" class="headerlink" title="实验难点分析"></a>实验难点分析</h2><p>lab4 的主要内容主要包括系统调用、进程通信机制（ipc）以及 fork 操作。我觉得实验的难点在于对系统调用流程的理解和实现。在做实验的时候很容易忘记自己是基于内核还是基于用户。</p><p>而<code>fork</code>操作的难点在于理解子进程如何继承父进程的上下文，即，什么样的页面需要被赋予 COW 属性。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab4的上机还是比较轻松的。exam大概用了20分钟就写完了，主要就是要理解用户态和内核态函数调用的层次逻辑。extra有点难度，最后只拿了50分。整体感觉下来还是对C语言不够熟悉，有很多代码逻辑不是很清晰。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab3_实验报告</title>
      <link href="/2025/04/25/OS-Lab3/BUAA-OS-Lab3%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/04/25/OS-Lab3/BUAA-OS-Lab3%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab3-实验报告"><a href="#BUAA-OS-Lab3-实验报告" class="headerlink" title="BUAA_OS_Lab3_实验报告"></a>BUAA_OS_Lab3_实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><blockquote><p>请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code> 的含义。</p></blockquote><ul><li><code>e-&gt;env_pgdir</code> 代表当前进程的页目录的基地址。在 MOS 中，每个进程都有自己的页目录，用于存储该进程的页表信息。</li><li><code>PADDR(e-&gt;env_pgdir)</code> 代表这个函数获取页目录的物理地址。<code>PADDR</code>是一个宏，用于将内核虚拟地址转换为物理地址。</li><li><code>PTE_V</code> ：这是一个标志位，表示页表项有效。<code>PADDR(e-&gt;env_pgdir) | PTE_V</code>，表示给页目录的物理基地址加上权限位。</li><li><code>PDX(UVPT)</code>：这是一个宏，用于获取虚拟地址 <code>UVPT</code> 的页目录索引。</li></ul><p>所以，这行代码的作用是将当前进程的页目录的物理地址映射到用户虚拟地址空间的<code>UVPT</code>地址处，并设置页表项为有效。这样，进程就可以在自己的地址空间中访问页表和页目录，提高了访问效率。</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><blockquote><p><code>elf_load_seg</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。 请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote><p>在 <code>elf_load_seg</code> 函数中，<code>data</code> 参数是一个指向用户自定义数据的指针，它将被传递给 <code>map_page</code> 回调函数。</p><p>在 <code>load_icode</code> 函数中，当调用 <code>elf_load_seg</code> 时，<code>data</code> 参数被设置为当前环境结构 <code>struct Env *e</code> 的地址。这样，在 <code>map_page</code> 回调函数中，可以通过 <code>data</code> 参数访问到当前环境的信息，例如页目录 <code>env_pgdir</code> 和地址空间标识符 <code>env_asid</code>，这些信息对于将页面插入到正确的进程地址空间至关重要。</p><p>因此，<code>data</code> 参数是必需的，它使得 <code>elf_load_seg</code> 和 <code>map_page</code> 函数能够与调用者之间传递必要的数据。</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><blockquote><p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote><ul><li>处理程序段的虚拟地址 <code>p_vaddr</code> 没有对齐到页边界的情况，计算偏移量并实现对齐。</li><li>在任何调用 <code>map_page</code> 的地方，如果 <code>map_page</code> 返回非零值，表示映射失败，<code>elf_load_seg</code> 函数都会立即返回这个错误值。</li><li>如果段的内存大小 <code>p_memsz</code> 大于文件的尺寸 <code>p_filesz</code>，说明段在内存中比在文件中占据更多的空间。在这种情况下，需要额外分配页来填充这部分空间。</li></ul><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><blockquote><p>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：</p><ul><li>你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</li></ul></blockquote><p>虚拟地址。<code>CP0</code>中存储的<code>EPC</code>是CPU产生异常的指令地址，对于CPU来说，其所见的都是虚拟地址。</p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><blockquote><p>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用）涉及的 <code>do_syscall()</code> 函数将在 Lab4 中实现。</p></blockquote><p><code>genex.S</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM7</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">timer_irq:</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill</span><br><span class="line"></span><br><span class="line">#if !defined(LAB) || LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><blockquote><p>阅读 <code>entry.S</code>、<code>genex.S</code> 和 <code>env_asm.S</code> 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p></blockquote><ol><li>异常处理。当发生异常的时候，会通过<code>mfc0 t0, CP0_STATUS</code>和<code>mtc0 t0, CP0_STATUS</code>指令来修改<code>CP0_STATUS</code>来关闭中断</li><li>系统调用</li><li>当异常处理或系统调用完成后，会通过 <code>ret_from_exception</code> 标签返回。在这里，会执行 <code>RESTORE_ALL</code> 和 <code>eret</code> 指令来恢复寄存器状态并返回到发生异常前的状态。</li><li>进程切换。</li></ol><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><ol><li>通过时钟中断来触发异常</li><li>异常处理程序先确定是时钟中断，并调用调度函数</li><li>调度函数通过一定的调度算法，选择一个新的进程开始执行</li><li>操作系统执行上下文的切换，保存当前进程、恢复新进程的状态</li><li>返回，执行新进程</li></ol><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次的课下lab虽然内容有点多但是整体难度其实不高，<del>毕竟跟着注释写就完事了</del>，但是比较难的是我们要对新增的文件以及我们在这个lab干了什么做一个比较完整的把握。</p><p>相比较之前的lab，这次的lab比较注重和理论课的联系，把理论课上进程调度仔细学好，才能好好参加本次的exam。建议一定要通读新增文件的每个函数的<code>Overview</code>，无论是否要求自己补全的</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次课下lab花费的时间不多，代码填空也没有很复杂的函数调用，所以仅仅完成课下任务是不行的，远不足以支撑我们完成限时测试。</p><p>另外，本次上机出现了一个令人难绷的bug，好在20:55的时候非常极限的找到并提交了，不得不说抗压能力是很重要的~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit2_单元总结</title>
      <link href="/2025/04/20/OO-Unit2%E6%80%BB%E7%BB%93/OO-Unit2%20%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/"/>
      <url>/2025/04/20/OO-Unit2%E6%80%BB%E7%BB%93/OO-Unit2%20%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第二单元总结"><a href="#「BUAA-OO」第二单元总结" class="headerlink" title="「BUAA OO」第二单元总结"></a>「BUAA OO」第二单元总结</h1><h2 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h2><h3 id="写在动手之前"><a href="#写在动手之前" class="headerlink" title="写在动手之前"></a>写在动手之前</h3><p>在开始本次作业之前，需要明确几个问题：</p><p><strong>1.需要哪些线程</strong></p><p>首先自然是6个电梯6个线程，然后便是输入线程</p><p><strong>2.有哪些共享对象</strong></p><p>因为乘客都已经分配给某个电梯了，乘客自然就不能算共享对象，因为乘客只独属于某个电梯（线程）。那么还有什么算共享对象呢，笔者觉得应该是任务列表类。输入线程把读到的请求写到任务列表里面，6个电梯线程对任务列表进行读操作，获取属于各自的请求，完成请求后写回任务列表。</p><p>综上所述，整体框架就已经很明确了，在<code>MainClass</code>类里面，需要把6个电梯线程<code>Elevator</code>依次启动，再把输入线程<code>InputThread</code>启动，每个电梯线程有一个自己的任务列表<code>QuestList</code>，然后<code>InputThread</code>就根据请求的要求（电梯id）来把请求放到人物列表中，由电梯去完成</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_fifth.png" alt="第一次作业类图-电梯系统类图"></p><p>第一次作业类图如图所示，整体按照<em>生产者-消费者模型</em>去搭建的，美中不足的一点是笔者没有写分配器类，这样这个作业的可迭代性就不好</p><h3 id="同步块设计与锁"><a href="#同步块设计与锁" class="headerlink" title="同步块设计与锁"></a>同步块设计与锁</h3><p>第一次作业笔者只是用了<code>synchronized</code>关键字，并没有使用其他的锁。</p><p><img src="/img/OO-Unit2/synchronized.png" alt="第一次作业synchronized方法"></p><p>如图所示，笔者只在<code>QuestTable</code>里面用了<code>synchronized</code>方法，使得<code>InputThread</code>和<code>Elevator</code>线程对其操作是线程安全的。java目前的实现中<code>synchronized</code>的效率也是很高的，所以这种方法很清晰。不过荣老师上课讲过，最好应该是使用<code>synchronzied</code>代码块来上锁，这样更清晰，可拓展性也好，<strong>不要在方法上上锁</strong>。</p><h3 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h3><p>本次作业笔者主要采用了LOOK策略，逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*电梯内有人要出电梯或者电梯外有人要进电梯*/</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Operation.OPEN; <span class="comment">// 电梯开门</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*电梯内有人*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Operation.CONTINUE; <span class="comment">// 电梯按当前方向继续运行</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 电梯内没人</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/*所有电梯的任务表都为空*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="comment">/*所有请求都已完成*/</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.END; <span class="comment">// 电梯终止运行</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.WAIT; <span class="comment">// 电梯等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="comment">/*当前方向上还存在请求*/</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.CONTINUE; <span class="comment">// 电梯按当前方向继续运行</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.REVERSE; <span class="comment">// 电梯掉头</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>Opreation</code>是一个枚举类，用来规定电梯的各种动作。</p><p>顺带一提，生活中绝大多数的电梯执行的都是LOOK策略。</p><p>此外，笔者还实现了电梯<del>踹人</del>的策略，也就是在同方向上，若是电梯已满，且门外有优先级比电梯内高的请求，两者交换一下。第一次作业没有<code>RECEIVE</code>的要求，该方案实现起来非常简单。</p><h3 id="代码量和类复杂度分析"><a href="#代码量和类复杂度分析" class="headerlink" title="代码量和类复杂度分析"></a>代码量和类复杂度分析</h3><p><img src="/img/OO-Unit2/Code_fifth.png" alt="第一次作业代码量"></p><p>第一次作业的代码量整体比较少，集中在<code>Elevator</code>类和<code>QuestTable</code>类中。</p><p><img src="/img/OO-Unit2/Magnanimity_fifth.png" alt="第一次作业OO度量"></p><p><code>Elevator</code>类，<code>QuestTable</code>类和<code>Scheduler</code>类的复杂度都比较高。其中<code>Elevator.run()</code>中有<code>while</code>循环和大量<code>if</code>条件判断，而<code>Shceduler</code>类中的<code>existQuest</code>方法和<code>nextOperation</code>方法也是如此，所以复杂度比较高。</p><h3 id="值得注意的bug"><a href="#值得注意的bug" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>笔者在实现电梯的过程中没有什么印象深刻的bug，不过在互测中找到了别人的bug。我们知道，当我们对一个容器进行边遍历边移除的时候，会发生<code>ConcurrentModificationException</code>，因此我们需要使用迭代器来遍历。然而当<strong>两个线程同时对某个容器进行操作</strong>的时候，即使使用了迭代器，依然会有<code>CME</code>错误。因此，对共享类进行严格的线程安全保证是很重要的。</p><h2 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h2><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_sixth.png" alt="第六次作业类图"></p><p>类图如上图所示</p><p>这一次的作业整体要复杂一点，首先不再为每个乘客规定电梯了，其次对电梯也增加了临时调度请求，整体的复杂度很高，<del>笔者也几乎写了整个清明节假期</del></p><p>这一次加入了新的线程<code>Manager</code>，用来将每个请求分配给电梯。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>在浏览往届学长学姐的帖子的时候，偶然发现了这个学长的<a href="https://blog.csdn.net/weixin_73635758/article/details/137831524?spm=1001.2014.3001.5501">博客</a>，学到了一个经过合理建模后的打分算法，整体体验下来效果很好，不逊于影子电梯。主要逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的分数为电梯从当前楼层出发到接到乘客共运行的楼层数</span></span><br><span class="line"><span class="comment">//在QuestScheduler里取分数最低的电梯分配该乘客</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(Quest quest)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*乘客需求方向与电梯运行方向相同*/</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*电梯内人数+与电梯运行方向相同的剩余任务数&lt;电梯容量*/</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*电梯无需掉头即可接到乘客*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">/*电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//需要掉头</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">/*电梯运行一圈的楼层数-电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//电梯这趟接不到乘客</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*电梯接到乘客需要遍历的圈数x电梯运行一圈的楼层数-电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//乘客需求方向与电梯运行方向相反</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过笔者的优化，笔者将电梯运行一圈的楼层数做了一个期望计算，最后的结果约为9-10之间，最后选择了9。第六次作业的强侧得分为95.25分，整体结果还算满意。</p><p>除此以外，整体的调度算法没有改变，一个值得注意的点，就是本次作业的<code>RECEIVE</code>要求使得踢人的实现变得略有复杂，再经过长时间的优化而<del>一直出bug</del>之后，笔者<del>有点自暴自弃，干脆</del>放弃了此策略</p><p>另外有一个让人笑话的点，就是笔者没有想到可以在接收到<code>SCHE</code>时就把电梯内部的乘客放出，反而是让乘客全程跟着电梯跑去临时调度的目标楼层，浪费了一些性能分。</p><h3 id="代码量和复杂度分析"><a href="#代码量和复杂度分析" class="headerlink" title="代码量和复杂度分析"></a>代码量和复杂度分析</h3><p><img src="/img/OO-Unit2/Code_sixth.png" alt="第六次作业代码量"></p><p>可以看到本次作业的代码量一下子就上去了，最多的是在<code>Elevator</code>类里面，对于实现<code>RECEIVE</code>和<code>SCHE</code>花费了大量的精力和代码。</p><p><img src="/img/OO-Unit2/Magnanimity_sixth.png" alt="第六次作业复杂度"></p><p>通过复杂度也可以看出，<code>Elevator</code>类确实变得过于复杂，其中主要是打分算法有较多的条件判断等。而执行分配调度的<code>Manager</code>类也是如此。</p><h3 id="值得注意的bug-1"><a href="#值得注意的bug-1" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>本次主要的bug有一个，在中测结束前通过笔者的评测机发现了。有时候，电梯可能会同时输出一个<code>RECEIVE</code>和一个<code>SCHE-BEGIN</code>。最后检查发现是在执行临时调度的开始阶段，笔者把锁挂在了电梯身上，而不是未完成请求列表，这导致分配线程在此期间还可以房屋内未完成请求列表，并把一个请求分配给该电梯。而对于笔者的实现，输出<code>RECEIVE</code>是交给分配器的，因此会导致同时输出。</p><p>在互测中，笔者发现同房间同学的一个有趣的bug。该同学似乎为了追求性能，尽量在输出<code>SHCE-BEGIN</code>前多跑几层楼。因此，笔者构造了一个跨度较长的<code>SCHE</code>请求，把电梯卡在极限距离，让该电梯的相应<code>SCHE</code>时间超过规定时间了。</p><h2 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h2><h3 id="如何处理轿厢不碰撞"><a href="#如何处理轿厢不碰撞" class="headerlink" title="如何处理轿厢不碰撞"></a>如何处理轿厢不碰撞</h3><p>经历过前两次作业的<del>折磨</del>之后，这个问题其实很容易想到解决办法。笔者在电梯内部新建一个<code>TargetFloor</code>对象，对于同一个井道的两个电梯，它们共享这一个楼层。笔者令到达换乘层的电梯获取换乘层对象的锁，在离开该层时释放换乘层对象的锁。需要注意的是，到达与离开均以输出为标准</p><h3 id="如何实现双轿厢电梯"><a href="#如何实现双轿厢电梯" class="headerlink" title="如何实现双轿厢电梯"></a>如何实现双轿厢电梯</h3><p>笔者的实现十分的不优雅。</p><p>调度器分别把这个<code>update</code>请求交给A、B两部电梯，两部电梯同时开始改造，分别放出其内部的乘客、修改参数信息（最高到达楼层等），而这个过程中的<code>UPDATE-BEGIN</code>等，均由A电梯来进行输出，不过很快笔者就发现这样的实现是有问题的。</p><p>尽管两部电梯同时接受到了来自调度器的请求，但这不能保证两部电梯可以同时进行<code>UPDATE</code>，或者说<code>UPDATE</code>的进度能保持一样，这就导致了有可能当A电梯已经输出了<code>UPDATE-BEGIN</code>的时候，B电梯还在放出客人；或者当A电梯尚未输出<code>UPDATE-END</code>的时候，B电梯已经完成了改造，开始<code>RECEIVE</code>乘客了。</p><p>笔者最后采用了这样的方法：对于一个update的请求，其内部设置三个方法，分别是<code>UPDATE</code>的准备、开始和结束。每个方法要求两部电梯都执行一次，才会使得电梯同步进入下一阶段。其实更优雅的方法就是把输出也放置到这些方法中，但笔者没有更改。</p><h3 id="整体架构-2"><a href="#整体架构-2" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_seventh.png" alt="第七次作业类图"></p><p>类图如上所示，架构较上一次作业没有太大变化。</p><h3 id="代码量和复杂度分析-1"><a href="#代码量和复杂度分析-1" class="headerlink" title="代码量和复杂度分析"></a>代码量和复杂度分析</h3><p><img src="/img/OO-Unit2/Code_seventh.png" alt="第七次作业代码量"></p><p>第七次作业代码量突破了1000行，其实整体上还是有东西可以合并的，在代码块中有几处重复或者高度相似的代码段。主要集中在<code>Elevator</code>类里面。</p><p><img src="/img/OO-Unit2/Magnanimity_seventh.png" alt="第七次作业复杂度"></p><p>作业整体的复杂度也很高，集中在电梯、调度器等。为了迎合双轿厢电梯的改造，<code>Scheduler</code>，即电梯行为的指示器，复杂度也变高了。</p><h3 id="值得注意的bug-2"><a href="#值得注意的bug-2" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>本次作业出现的有趣的bug都在开头部分交代了。在强测和互测中均没有跑出bug。</p><h2 id="同步块和锁"><a href="#同步块和锁" class="headerlink" title="同步块和锁"></a>同步块和锁</h2><p>本次作业中，笔者主要使用的都是<code>synchronized</code>关键字。在第六次作业的实现过程中，笔者初步尝试了使用读写锁，但是在自己评测的过程中出现了很多难以修复的<del>奇妙</del>bug，<del>遂作罢</del>，改回<code>synchronized</code>。另外，对于很多私有变量，我使用了<code>AtomicBoolean</code>以及<code>AtomicInteger</code>，降低了锁的使用频率。java保证了对这些变量的读写都是原子性的。</p><h2 id="bug以及debug方法"><a href="#bug以及debug方法" class="headerlink" title="bug以及debug方法"></a>bug以及debug方法</h2><p>本次电梯单元，笔者是无伤通关，强测互测均没有出现bug。对于debug，笔者有一些自己比较好用的方法：</p><ol><li>调试输出<br> 多线程的bug并不能稳定复现，而且也不能通过打断点的方法去debug，因此我们可以进行调试输出，也就是在一些关键地方输出一些能反映线程参数的信息。比如在线程结束时，让线程输出<code>end</code>等，这样可以观察有哪些线程可能没有正常结束，进而发现程序中的缺陷</li><li>代码走查<br> 代码走查指的是在代码写完之后通读代码全体，检查代码潜在的bug。笔者主要通过这种方法来寻找可能出现的线程不安全问题，也确实用这样的方法成功的查漏补缺了。</li><li>构造评测机<br> 自动化评测对于多线程问题来说，笔者认为是必要的。大量的测试点才有可能测出多线程项目中潜在的问题，人工构造的测试点并不总能很好的”压迫边界“。构造评测机方法，详情可以看笔者的<a href="http://oo.buaa.edu.cn/assignment/624/discussion/1691">讨论区帖子</a>，抑或是已经同步更新的<a href="https://www.oldjoy.top/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/">博客</a>。</li></ol><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>经历了面向对象和操作系统的<del>双重折磨</del>，笔者算是对多线程有了一点理解。对于多线程编程，同步与互斥，也就是线程安全，是多线程编程最核心的内容之一。</p><p>笔者在测试中没有发现自己的任何有关线程安全的bug，这主要归功于在开始学习多线程编程之前，笔者对线程问题进行了细致系统的学习。尽管如此，笔者也并不认为自己对线程安全已经完全掌握。本次作业并发程度并不高，共享资源并不复杂，尚且没有达到生活中常见的多线程问题（12306），只能说对多线程初窥门径。</p><h2 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h2><p>本次作业的核心架构没有离开多线程架构中经典的<strong>生产者-消费者模型</strong>，而经历了操作系统的学习之后，这样的模型其实还有更多、更复杂、同样很精巧的模型。</p><p>层次化设计要求编程者自顶向下对整个设计任务进行分层分块，并对每层每块分别建类实现。高层的类只关注抽象后的功能调用，而底层的类则负责每种功能的具体实现。这样的做法在降低每层代码的复杂度发同时也会增加程序的代码总量，所以应该合理平衡代码复杂度与代码量。</p><p>本次作业中，我的层次化设计整体还算比较好，每个类负责的功能比较单一，类间逻辑比较清晰。但其实还可以做的更好，有很多可以继续抽象的地方尚可优化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab2_实验报告</title>
      <link href="/2025/04/11/OS-Lab2/BUAA-OS-Lab2%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/04/11/OS-Lab2/BUAA-OS-Lab2%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h2><blockquote><p>请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</p></blockquote><p>C 语言中指针变量储存的地址是虚拟地址，汇编代码中 lw 和 sw 指令中使用的地址也是虚拟地址。</p><h2 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h2><blockquote><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的 &#x2F;usr&#x2F;include&#x2F;sys&#x2F;queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul></blockquote><ol><li><p>使用宏来实现链表的好处有以下几个方面：</p><ul><li>代码复用：宏可以使链表的定义和操作变得通用，不受特定数据类型的影响。通过宏，可以在不同的数据结构中重用相同的链表实现代码，只需简单地将链表节点中的数据类型进行替换即可。</li><li>类型无关性：宏允许链表操作与具体的存储类型无关，这意味着同一个宏定义可以用于创建存储不同类型数据的链表。</li><li>性能优势：宏在编译时会被直接替换为相应的代码，没有函数调用的开销。这可以减少程序运行时的性能损耗。</li></ul></li><li><p>阅读了系统中<code>queue.h</code>可以得到以下结论</p><ul><li>单项链表如果要插入到链表中间的某个位置，需要从头部遍历一遍才能找到相应的位置，这个事件复杂的是 O(n)；</li><li>而双向链表记录了元素的前驱和后继，它对于任意元素在任意给定位置的插入和删除操作时间复杂度都只有 O(1)；</li><li>循环列表本质和单向链表差不多</li></ul></li></ol><h2 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h2><blockquote><p>请阅读 include&#x2F;queue.h 以及 include&#x2F;pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125; lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应当选择<code>C</code>。<br>关于<code>Page</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;  <span class="comment">/* free list link */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而关于<code>Page_LIST_entry_t</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">        struct &#123;                                                                \</span></span><br><span class="line"><span class="meta">                struct type *le_next;   <span class="comment">/* next element */</span>                      \</span></span><br><span class="line"><span class="meta">                struct type **le_prev;  <span class="comment">/* address of previous next element */</span>  \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h2><blockquote><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul></blockquote><p>在多进程环境中，每个进程都有自己的虚拟地址空间，这些地址空间通常是独立的。ASID用于在TLB中区分不同进程的页表项，确保每个进程只能访问自己的内存地址，从而实现进程间的隔离。</p><p>ASID使得操作系统在管理内存时更加灵活和高效。它允许操作系统为每个进程分配一个唯一的标识符，而不需要关心进程的具体虚拟地址空间布局，从而简化了内存管理的工作。</p><p>当CPU进行上下文切换时，如果没有ASID，则需要将TLB中的所有条目刷新，因为新的进程可能会使用相同的虚拟地址，而这些地址在TLB中可能映射到不同的物理地址。ASID允许TLB保留多个进程的条目，只有当切换到具有相同ASID的进程时才需要刷新相关的TLB条目，减少了不必要的刷新操作。</p><p>ASID 6 位，因此可以最多容纳 64 个不同的地址空间。</p><h2 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h2><blockquote><ul><li>tlb_invalidate 和 tlb_out 的调用关系？</li><li>请用一句话概括 tlb_invalidate 的作用。</li><li>逐行解释 tlb_out 中的汇编代码。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">    tlb_out((va &amp; ~GENMASK(PGSHIFT, <span class="number">0</span>)) | (asid &amp; (NASID - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是<code>tlb_invalidate</code>调用<code>tlb_out</code></p><p>逐行解释如下：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out) <span class="comment"># 标记这是一个叶子函数，即它不会调用其他函数，也不会保存其他寄存器的状态。</span></span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder </span><span class="comment"># 告诉汇编器不要对指令进行重新排序，确保指令按照写的顺序执行</span></span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI <span class="comment"># 将 CP0 寄存器中的 ENTRYHI（TLB 的键字段）内容复制到通用寄存器 t0 中，保存原始的 ENTRYHI 值</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">a0</span>, CP0_ENTRYHI <span class="comment"># 将传入的参数（a0 寄存器中的值）复制到 CP0 的 ENTRYHI 寄存器中，准备进行TLB操作</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.8: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbp </span><span class="comment"># 根据 EntryHi 中的 Key，查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 2: Fetch the probe result from CP0.Index */</span></span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t1</span>, CP0_INDEX <span class="comment"># 将 CP0 的 INDEX 寄存器内容（TLB 探测的结果）复制到通用寄存器 t1 中</span></span><br><span class="line">    <span class="meta">.set</span> reorder</span><br><span class="line">    <span class="keyword">bltz </span>   <span class="built_in">t1</span>, NO_SUCH_ENTRY <span class="comment"># 如果 TLB 中没有找到对应的条目，跳转到 NO_SUCH_ENTRY 标签</span></span><br><span class="line">    <span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYHI</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO0</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO1 <span class="comment"># 把 CP0_ENTRYHI，CP0_ENTRYLO 全部设为 0，为清空 TLB 做准备</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.8: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbwi </span><span class="comment"># 将此时 EntryHi 与 EntryLo 的值，也就是 0，写到索引指定的 TLB 表项中，完成清空</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="meta">.set</span> reorder</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">NO_SUCH_ENTRY:</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI <span class="comment"># 将之前保存的原始 ENTRYHI 值写回到 CP0 的 ENTRYHI 寄存器中，恢复上下文</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="built_in">ra</span> <span class="comment"># 返回</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><h2 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h2><p>三级页表页目录的基地址<br><code>&#123;PTbase[38:30], PTbase[38:30], PTbase[38:30], 12&#39;h0&#125;</code></p><p>映射到页目录自身的页目录项（自映射）<br><code>&#123;PTbase[38:30], PTbase[38:30], PTbase[38:30], PTbase[38:30], 3&#39;h0&#125;</code></p><h2 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h2><ol><li>CPU 发出访问指令: 用户进程执行内存访问。</li><li>查询 TLB: 硬件自动执行。</li><li>触发 TLB Miss (No 分支): 硬件检测到 TLB 未命中，跳转到内核 TLB Miss 处理程序。</li><li>根据页目录表和虚拟地址寻找页表项 &#x2F; 从页表中查找页表项: 主要由 <code>page_lookup</code> 函数实现。它遍历页目录和页表，查找对应的页表项 (PTE)。</li><li>页目录项&#x2F;页表项是否有效:<ul><li>否 (No 分支 - 页面&#x2F;页表不存在或无效):<ul><li>分配新页面&#x2F;页表: 可能涉及 <code>page_alloc</code> (分配物理页) 和 <code>page_insert</code> (建立映射，填写 PTE)。<em>（流程图简化了分配页表本身，Lab2 主要处理页面的分配和插入）</em></li></ul></li><li>是 (Yes 分支 - 找到有效 PTE): <code>page_lookup</code> 成功返回有效的 PTE。</li></ul></li><li>取出物理页号 PPN … 写入 TLB: 由 <code>_do_tlb_refill</code> 函数在 <code>page_lookup</code> 成功后，读取 PTE 信息，并使用特定 CPU 指令将映射关系写入硬件 TLB。</li><li>重新访问 &#x2F; 读取到 PPN 结合 offset 完成访问 (Yes 分支): TLB refill 完成后，指令重新执行，此时 TLB Hit，硬件使用 TLB 中的 PPN 完成地址翻译和访问。</li></ol><p><strong>核心关系</strong>: Lab2 中的 <code>do_tlb_refill</code>、<code>page_lookup</code>、<code>page_alloc</code>、<code>page_insert</code> 等函数共同构成了 CPU 访问流程图中 <strong>TLB Miss 发生后由软件执行的页表查找、页面分配（如果需要）、页表更新以及最终填充 TLB 的处理逻辑</strong>。</p><h2 id="Thinking-2-7"><a href="#Thinking-2-7" class="headerlink" title="Thinking 2.7"></a>Thinking 2.7</h2><ul><li>X86 体系结构中的内存管理机制<ul><li>通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。</li><li>逻辑地址由两部分构成，一部分是段选择器，一部分是偏移。</li><li>段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；</li><li>偏移与对应段描述符中的基地址相加就是线性地址。</li><li>操作系统创建全局描述符表和提供逻辑地址，之后的分段操作x86的CPU会自动完成，并找到对应的线性地址。</li><li>从线性地址到物理地址的转换是CPU自动完成的，转化时使用的Page Directory和Page Table等需要操作系统提供。</li></ul></li><li>X86 和 MIPS 在内存管理上的区别<ul><li>TLB不命中：<ul><li>MIPS触发TLB缺失和充填，然后CPU重新访问TLB</li><li>x86硬件MMU索引获得页框号，直接输出物理地址，MMU充填TLB加快下次访问速度</li></ul></li><li>分页方式不同：<ul><li>一种MIPS系统内部只有一种分页方式</li><li>x86的CPU支持三种分页模式</li></ul></li><li>逻辑地址不同：<ul><li>MIPS地址空间32位</li><li>x86支持64位逻辑地址，同时提供转换为32位定址选项</li></ul></li><li>段页式的不同：<ul><li>MIPS同时包含了段和段页式两种地址使用方式</li><li>在x86架构的保护模式下的内存管理中，分段是强制的，并不能关闭，而分页是可选的；</li></ul></li></ul></li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><ul><li><p>物理内存管理部分，我感觉难度相对适中。主要任务是填充链表宏定义和实现几个关键函数。</p><ul><li>链表宏：这部分的关键在于理解双向链表的原理。虽然填充本身不难，但在动手前需要仔细阅读多个相关文件中的代码，并结合已有的宏定义，才能准确把握传入参数的含义。</li><li>函数实现：这部分则要求对各个变量间的逻辑关系有清晰的认识，特别是要理解 ROUND 函数的作用以及页控制块（Page Control Block）及其内部变量的意义。只要理解了这些，依照代码注释中的提示来完成实现还是比较顺利的。</li></ul></li><li><p>虚拟内存管理部分，整体难度也感觉不算太高。</p><ul><li>核心在于掌握二级页表的工作机制，并熟悉相关的宏定义和函数调用方法。</li></ul></li><li><p>TLB 重填部分，需要编写的代码量不大。基本上是根据代码注释的要求，按部就班地完成指定的操作即可。</p></li></ul><p>总的来说，这次实验加深了我对操作系统内存管理机制的理解，尤其是在二级页表和地址转换的概念上有了更清晰的认识，尽管中间也遇到了一些理解上的挑战。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>面对庞大的现有代码库，我最初感到有些不知所措，直接上手完成任务确实困难。由于 Lab 2 的课下作业开始得比较晚，时间紧迫，我采取了先快速浏览一遍，然后就参照提示或模仿上下文代码来填充空白的策略。这种“依样画葫芦”的方式虽然让我较快地完成了任务，但明显感觉到自己对代码的理解并不深入。<br>意识到这一点后，在完成练习之后，我特意投入了大半天的时间。我结合指导书，从头到尾仔细研读了 pmap.c 文件中的每一个函数实现。同时，我也更细致地查看了相关的头文件，这不仅加深了我对 C 语言宏定义的理解，也让我对每个函数的功能和实现逻辑有了更清晰的认识，并为它们添加了自己的注释。在这个深入阅读和思考的过程中，许多之前模糊不清的地方豁然开朗，得到了合理的解释。后来通过与同学们的交流讨论，我对代码细节和内存管理机制的理解又得到了进一步的巩固和深化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我会构建健壮的多线程电梯评测机</title>
      <link href="/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/"/>
      <url>/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我会构建健壮的多线程电梯评测机-smiley"><a href="#我会构建健壮的多线程电梯评测机-smiley" class="headerlink" title="我会构建健壮的多线程电梯评测机:smiley:"></a>我会构建健壮的多线程电梯评测机:smiley:</h1><p>已同步更新至本人blog，欢迎大家来参观:blush:</p><p>对于像电梯这样的复杂的、行为不确定的并发系统，<strong>构建自动化、系统化、能够进行状态跟踪和规则检查的测试框架，是确保程序正确性、提高开发效率的必备手段</strong>。直接手动测试覆盖面有限，且难以复现并发问题。因此，构建一个自动化的、能够生成有强度数据的、能够精确判定正确性的评测机就显得尤为必要。<del>同学，你也不想你的代码被我们hack吧</del></p><p>在经历了 HW5 到 HW6 的迭代后，电梯系统的规则变得更加复杂。在此之前，我和舍友合力搭建了一套基于 Python 的自动化评测框架，希望能较为全面地测试电梯程序的健壮性和性能。经过了一次迭代，该评测机的性能和正确性能够做到更优。在此，我想分享一下这套评测机的核心思路和实现细节，希望能为大家提供一些参考</p><h2 id="一、-核心组件概览"><a href="#一、-核心组件概览" class="headerlink" title="一、 核心组件概览"></a>一、 核心组件概览</h2><p>我们的评测机主要由以下 Python 脚本构成：</p><ol><li><p><strong><code>generate_data.py</code></strong>: 负责生成符合要求的、具有不同侧重点和强度的测试输入数据 (<code>stdin.txt</code>)，包括乘客请求和临时调度 (SCHE) 请求</p></li><li><p><strong><code>validator.py</code></strong>: 核心验证逻辑所在。它读取输入数据，模拟电梯系统的预期行为，并逐行解析、验证程序的输出 (<code>stdout</code>) 是否符合指导书的所有正确性约束（时序、状态、规则等）</p></li><li><p><strong><code>run_test.py</code></strong>: 测试流程的“指挥官”。它负责调用数据生成器、在隔离环境中执行同学们的 Java 程序（通过官方提供的 <code>datainput.exe</code> 和 <code>java</code> 命令）、捕获输出、调用验证器进行判定，并最终汇总、报告测试结果</p></li><li><p>**<code>run_elevator_tests.bat</code> **: 一个简单的启动脚本，方便一键运行</p><p><img src="/img/Elevator-tester/composition.png" alt="核心组件"></p></li></ol><h2 id="二、-数据生成策略-generate-data-py"><a href="#二、-数据生成策略-generate-data-py" class="headerlink" title="二、 数据生成策略 (generate_data.py)"></a>二、 数据生成策略 (<code>generate_data.py</code>)</h2><p>生成高质量的测试数据是评测有效性的基础。我们的目标是覆盖各种边界情况和压力场景:smiling_imp:</p><p>这是保证我们评测机强度的核心了。之前我在高强度水群的时候发现，某位同学说ta的评测机跑了一整天全是AC </p><p>那当然是测试点强度还不够啦！尽管是随机生成，我们也要有策略、有侧重点地随机生成，不给点压力，你怎么知道代码会不会垮掉呢？<del>嘻嘻</del></p><p><strong>核心思路：分阶段、有侧重地生成请求。</strong></p><p>我们将总的模拟时间（公测约 60s+，互测 50s）划分为四个阶段，每个阶段投放不同特点的请求：</p><ul><li><strong>阶段一 (0% - 15% 时间, ~10% 请求): 稀疏试探</strong><ul><li><strong>目的</strong>: 模拟系统启动初期或低峰期，请求零散</li><li><strong>内容</strong>: 生成少量乘客请求，优先级随机偏低，并夹杂少量 SCHE 请求。测试电梯的启动、基本寻路和 SCHE 响应能力</li></ul></li><li><strong>阶段二 (15% - 50% 时间, ~40% 请求): 密集压力 I</strong><ul><li><strong>目的</strong>: 模拟高峰期，测试系统的吞吐能力和调度策略在高负载下的表现，<del>就好比下课时间大家蜂拥去食堂</del></li><li><strong>内容</strong>: 大量乘客请求涌入，时间戳<strong>相近</strong>或<strong>相同</strong>。乘客请求可能跨度较大。也包含一些 SCHE 请求，测试调度中断和恢复能力</li></ul></li><li><strong>阶段三 (50% - 75% 时间, ~20% 请求): 边界与特殊场景</strong><ul><li><strong>目的</strong>: 专门测试指导书中提到的或容易出错的边界情况</li><li><strong>内容</strong>:<ul><li><strong>极端距离</strong>: 如 B4 &lt;-&gt; F7。</li><li><strong>跨零层</strong>: 如 B1 &lt;-&gt; F1。</li><li><strong>短距离</strong>: 相邻楼层。</li><li><strong>SCHE 边界</strong>: 测试 SCHE 请求与普通请求的交互、SCHE 的快速响应、SCHE 期间乘客处理、完成 SCHE 需要的总时间等。生成 SCHE 请求时，会保守估计上一个 SCHE 的完成时间，确保两次 SCHE 之间有足够间隔</li></ul></li></ul></li><li><strong>阶段四 (75% - 100% 时间, ~30% 请求): 优先级与密集压力 II</strong><ul><li><strong>目的</strong>: 测试调度策略对优先级的响应，以及在接近结束时处理剩余请求的能力。很多同学想必都对优先级进行过优化，那么自然要有针对性的找问题，<del>桀桀桀</del></li><li><strong>内容</strong>: 生成大量同时间戳请求，这些请求中有极高优先级 (80-100) 和极低优先级 (1-10) 的请求，集中hack同学们针对优先级优化的地方。同时保持一定的请求密度。也包含 SCHE 请求</li></ul></li></ul><p><strong>其他生成细节:</strong></p><ul><li><strong>互测模式约束</strong>: 当检测到是互测模式时：<ul><li>最大数据投喂时间强制设为 50s</li><li>总请求数（乘客 + SCHE）严格控制在 70 条以内</li><li>每部电梯的 SCHE 请求数严格控制在 1 次以内</li></ul></li><li><strong>时间戳</strong>:<ul><li>保证第一条指令 <code>&gt;= 1.0s</code></li><li>使用插入并最后排序，确保输入文件中的精确时间戳<strong>非递减</strong></li><li>在最终输出到 <code>stdin.txt</code> 时，检查确保格式化后的时间戳也是<strong>非递减</strong>的（通过与上一个输出的时间戳比较调整）</li><li>添加微小随机扰动，避免大量完全相同的时间戳</li></ul></li></ul><h2 id="三、-正确性判定-validator-py"><a href="#三、-正确性判定-validator-py" class="headerlink" title="三、 正确性判定 (validator.py)"></a>三、 正确性判定 (<code>validator.py</code>)</h2><p>这是评测机的核心和最复杂的部分。它的运行思路是<strong>基于学生程序的输出日志，精确模拟电梯和乘客的状态变化，并根据指导书的所有规则进行校验</strong>，<del>当然，这也是和大模型经过深刻交流后诞生的</del></p><p><strong>核心思路：状态机模拟 + 规则校验</strong></p><ol><li><p><strong>状态建模</strong>:</p><ul><li><code>PassengerState</code><strong>乘客状态</strong>: 记录每个乘客的 ID, 优先级, 起止楼层, 请求时间, <strong>当前位置</strong>, 当前状态, <strong>所在电梯</strong>, 以及<strong>被哪个电梯接收</strong></li><li><code>ElevatorState</code><strong>电梯状态</strong>: 记录电梯 ID, 当前楼层, 门状态, <strong>轿厢内乘客集合</strong>, <strong>已接收待处理乘客集合</strong>, 当前速度, <strong>调度状态</strong>, 临时调度信息, 以及<strong>上次动作完成时间</strong> 用于时序检查。</li></ul></li><li><p><strong>输出解析</strong>:</p><ul><li>逐行读取 <code>stdout</code>。</li><li>使用正则表达式精确匹配时间戳和事件内容。采用 <code>re.fullmatch</code> 确保内容完全符合预期格式。</li><li>解析出事件类型和参数（楼层、ID、速度等），进行基本类型和范围检查（如楼层是否有效，ID 是否在 1-6）。</li><li>时间戳检查: 全局检查输出时间戳是否非递减。</li></ul></li><li><p><strong>事件验证</strong>: 这个是正确性判定的关键了。对每个解析出的事件，根据当前模拟的系统状态（所有电梯和乘客的状态）和指导书规则进行检查：</p><ul><li><p><strong>基本移动 (<code>ARRIVE</code>)</strong>:</p><ul><li>检查门是否关闭</li><li>检查时间是否满足 <code>当前速度 * 1 层</code> 的要求（与上次动作完成时间比较，允许一定误差）</li><li>检查移动是否合法（相邻楼层或跨零层）</li><li>检查电梯在空闲时（无乘客、无接收）是否在 <code>RECEIVE</code> 后才移动（基础检查）</li></ul></li><li><p><strong>开关门 (<code>OPEN</code>&#x2F;<code>CLOSE</code>)</strong>:</p><ul><li>检查前置状态<del>开门前必须关门，关门前必须开门</del></li><li>检查是否在当前楼层操作</li><li>检查 <code>CLOSE</code> 距离对应的 <code>OPEN</code> 是否满足最小开门时间（普通 <code>0.4s</code>，SCHE 目标层 <code>1.0s</code>）</li></ul></li><li><p><strong>进出乘客 (<code>IN</code>&#x2F;<code>OUT</code>)</strong>:</p><ul><li>检查门是否打开</li><li>检查是否在电梯当前楼层</li><li><code>IN</code>: 检查电梯容量是否合法；检查乘客是否在当前楼层；<strong>检查乘客是否已被该电梯 <code>RECEIVE</code></strong>；<em>重要：<code>IN</code> 在电梯处于调度状态下禁止</em>。</li><li><code>OUT</code>: 检查乘客是否在该电梯内部；根据 <code>OUT-S</code>&#x2F;<code>OUT-F</code> 和是否到达目的地判断标志是否正确</li><li>状态更新：正确更新乘客的状态，包括所处楼层或所处电梯等</li></ul></li><li><p><strong>接收 (<code>RECEIVE</code>)</strong>:</p><ul><li><p>检查乘客是否处于等待电梯的状态中</p></li><li><p>检查乘客是否已被<strong>其他</strong>电梯接收</p></li><li><p>检查是否<strong>重复接收</strong>同一乘客</p><p>举个例子，下面是判定接受成功的部分代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function validate_receive(event):</span><br><span class="line">passenger = get_passenger(event.person_id)</span><br><span class="line">elevator = get_elevator(event.elevator_id)</span><br><span class="line">is_sche_active = (elevator.scheduling_state == ACTIVE)</span><br><span class="line"></span><br><span class="line">if is_sche_active://电梯仍在SCHE中</span><br><span class="line">    add_error(&quot;RECEIVE during SCHE ACTIVE&quot;)</span><br><span class="line">if passenger.state != WAITING: //乘客不属于等待状态（未投喂请求、已进入电梯等）</span><br><span class="line">    add_error(&quot;RECEIVE Passenger not WAITING&quot;)</span><br><span class="line">// 关键：检查是否已被任何电梯接收 (包括自己)</span><br><span class="line">if passenger.received_by_elevator != -1:</span><br><span class="line">     if passenger.received_by_elevator != event.elevator_id:</span><br><span class="line">         add_error(&quot;Passenger already received by another elevator&quot;)</span><br><span class="line">     else:</span><br><span class="line">         add_error(&quot;Duplicate RECEIVE by same elevator&quot;)</span><br><span class="line"></span><br><span class="line">// 如果检查通过:</span><br><span class="line">passenger.received_by_elevator = event.elevator_id</span><br><span class="line">elevator.received_passengers.add(event.person_id)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>临时调度 (<code>SCHE-ACCEPT</code>, <code>SCHE-BEGIN</code>, <code>SCHE-END</code>)</strong>:</p><ul><li><code>SCHE-ACCEPT</code>: 从输出解析，更新电梯状态为，记录调度信息（允许覆盖）。</li><li><code>SCHE-BEGIN</code>: 检查电梯是否处于接受调度状态；检查门是否关闭；检查电梯是否静止；检查距离 <code>SCHE-ACCEPT</code> 的 <code>ARRIVE</code> 次数 (<code>&lt;= 2</code>)；<strong>关键：将该电梯所有的已经<code>RECEIVE</code>到的乘客状态设为未接收，并清空电梯的“已RECEIVE乘客”集合</strong>；设置状态为处于临时调度中，更新运行速度。</li><li><code>SCHE-END</code>: <strong>检查电梯是否处于临时调度中</strong>；检查电梯是否在目标楼层；检查是否空载；检查门是否 <code>CLOSED</code>；检查总响应时间（不能超过6s）；检查之前是否有合法的 <code>OPEN</code> -&gt; (等待1s) -&gt; <code>CLOSE</code> 序列；设置状态为正常，恢复默认速度。</li></ul></li></ul></li><li><p><strong>最终状态检查</strong>:</p><ul><li>所有乘客状态是否为 <code>ARRIVED</code>。</li><li>所有电梯状态是否为 <code>IDLE</code>，是否空载，门是否 <code>CLOSED</code>，速度是否恢复默认。</li></ul></li></ol><h2 id="四、-自动化与执行流程-run-test-py"><a href="#四、-自动化与执行流程-run-test-py" class="headerlink" title="四、 自动化与执行流程 (run_test.py)"></a>四、 自动化与执行流程 (<code>run_test.py</code>)</h2><p>为了方便、高效地进行大量测试，自动化流程必不可少，你也很喜欢点点鼠标就自动开始评测对吧:yum:</p><ol><li><p><strong>模式选择</strong>: 启动时询问用户选择“公测”或“互测”模式，加载对应的参数（如最大请求投喂时间，数据生成范围等）</p></li><li><p><strong>并行测试</strong>: 使用 <code>concurrent.futures.ProcessPoolExecutor</code> 并行运行多个测试实例，显著缩短总测试时间</p></li><li><p><strong>环境隔离</strong>:</p><ul><li>为每个测试实例创建一个独立的子目录</li><li>将学生的代码 JAR包、官方的JAR包和数据投喂包复制到子目录中</li><li>在该子目录中生成独立的 <code>stdin.txt</code></li><li><strong>作用</strong>: 防止不同测试实例之间因共享文件或状态产生干扰，确保测试的可重复性</li></ul></li><li><p><strong>命令执行与 I&#x2F;O</strong>:</p><ul><li>使用 <code>subprocess.Popen</code> 在子目录中执行数据投喂命令</li><li>通过管道捕获 Java 程序的 <code>stdout</code> 和 <code>stderr</code></li><li>设置超时 (<code>timeout</code> 参数)，在超时后将超时判断设置为真</li></ul></li><li><p><strong>超时处理</strong>: 即使进程超时，仍会<strong>尝试读取已有的输出</strong>，并<strong>继续执行验证逻辑</strong>。最终结果会被标记为 <code>FAIL_TIMEOUT</code>，但日志中会包含验证器对部分输出的检查结果，有助于分析超时前的行为。</p></li><li><p><strong>Stderr 检查</strong>: 严格检查 <code>stderr</code> 是否有任何输出。根据指导书要求，任何 <code>stderr</code> 输出都视为错误</p></li><li><p><strong>结果汇总与报告</strong>:</p><ul><li>收集每个测试的状态 (<code>PASS</code>, <code>FAIL_VALIDATE</code>, <code>FAIL_TIMEOUT</code>, <code>FAIL_JAVA_ERROR</code>, <code>FAIL_STDERR_OUTPUT</code> 等)</li><li>计算通过率，清晰地列出失败的测试点及其主要原因</li><li>对于失败的测试点，<strong>自动保存</strong>其输入数据 (<code>failed_data_...txt</code>) 和详细日志 (<code>failed_stdout_...txt</code>) 到 <code>test_results_hw6</code> 目录。日志中包含：测试信息、stdin、stdout、stderr、以及 <code>validator.py</code> 报告的所有错误信息和 <strong>Traceback (用于调试评测机本身)</strong></li></ul></li><li><p><strong>自动清理</strong>: 测试结束后，自动删除所有临时的子目录。在开始新一轮测试前，也会清理旧的结果目录 <code>test_results_hw6</code></p><p><img src="/img/Elevator-tester/result.png" alt="评测结果"></p></li></ol><h2 id="五、-总结与思考"><a href="#五、-总结与思考" class="headerlink" title="五、 总结与思考"></a>五、 总结与思考</h2><p>这套评测框架旨在通过<strong>自动化、并行化、多阶段数据生成、精细化状态模拟和严格规则校验</strong>，尽可能全面地测试多线程电梯程序的正确性，事实上，两次作业我用这个评测机找到了程序中很多隐蔽的bug，并在互测中成功击落了几个大佬的程序，战绩可查:sunglasses:</p><p><strong>优点</strong>:</p><ul><li><p><strong>自动化程度高</strong>: 一键运行，自动生成数据、执行、判定、报告、清理</p></li><li><p><strong>测试效率高</strong>: 并行执行大大缩短了测试时间，经过舍友的优化，一键脚本支持多个JAR包同时开跑，<del>晚上睡觉前把房间里所有同学的代码都打包好然后狠狠跑他5000组数据</del>，大大提高了评测效率</p><p><img src="/img/Elevator-tester/condition.png" alt="评测现状"></p></li><li><p><strong>数据有针对性</strong>: 分阶段生成数据，兼顾了压力和边界情况</p></li><li><p><strong>判定较严格</strong>: 尽可能覆盖了指导书中的显式和隐式规则。</p></li></ul><p><strong>待改进之处</strong>:</p><ul><li><strong>性能分计算</strong>: 当前验证器只计算了性能分的三要素 (<code>T_run</code>, <code>WT</code>, <code>W</code>)，并未实现指导书中复杂的相对评分公式。</li><li><strong>“Quantum Elevator” 检测</strong>: 精确检测<code>电梯空闲状态下收到RECEIVE后未等待0.4s即ARRIVE</code>需要复杂的状态回溯，目前实现是近似的，可能存在少量误判或漏判。</li><li><strong>SCHE 间隔保证</strong>: 数据生成器中对两次 SCHE 间隔的保证是基于一个保守的固定时间估计，而非精确模拟，理论上仍有小概率生成不合规数据（尽管指导书保证输入数据是合理的）。</li><li><strong>验证器复杂度</strong>: <code>validator.py</code> 逻辑复杂，自身也可能存在未发现的 bug。</li></ul><p>总而言之，搭建这样一个评测机本身就是一次很好的面向对象设计和多方面考虑的练习。希望这个思路分享能对大家有所启发，也欢迎交流和指出其中的不足之处！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit1_单元总结</title>
      <link href="/2025/03/28/OO-Unit1%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83/"/>
      <url>/2025/03/28/OO-Unit1%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第一单元总结"><a href="#「BUAA-OO」第一单元总结" class="headerlink" title="「BUAA OO」第一单元总结"></a>「BUAA OO」第一单元总结</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>使用MetricsReload插件对我的项目进行分析，得到类的复杂度如下图所示，整体来看，主要复杂度高的地方在第二次作业和第三次作业迭代的地方，这也与我设计上有所欠缺有关。<br><img src="/img/OO-Unit1/magnanimity.png" alt="OO度量"></p><p><strong>架构优点</strong></p><ul><li>分类明确。每个类都处理好自己的工作，相互没有过多交集，所有的<code>get</code>方法我都是返回一个映射而非返回类成员本身，符合面向对象封装的思想。</li><li>可迭代性好。整体的迭代工作并不困难。</li></ul><p><strong>架构缺点</strong></p><ul><li>可读性差。在函数因子<code>FuncFactor</code>与函数定义<code>FuncCall</code>里面，在参数处理方面，我写了很大的<code>if - else</code>分支，导致了代码可读性很差，而且这样很容易漏掉一些情况，这也与我强测寄了有一定的联系</li><li>重复性高。出于一些原因<del>其实就是懒</del>，我没有对代码进行重构，导致在递推函数<code>FuncFactor</code>和普通函数<code>SimpleFuncFactor</code>里面存在大量的代码重复，没有提炼成合理的方法，确实是不可取的地方。</li></ul><p>类图如下</p><p><img src="/img/OO-Unit1/ClassDiagram.png" alt="类图"></p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>设计思路上，我套用了之前OOpre的第七次作业给的递归下降的模版，从表达式逐层下降解析，直到把整个表达式解析完成。在预处理和最后的化简阶段，我使用了一些正则表达式的知识，比如匹配并去除空白字符、匹配多余的<code>+</code>号，还有在输出之前去掉多余的<code>^1</code>等等。</p><p>而关于中间的单项式与多项式，第一次作业表达式的结果一定是<br>$$<br>\displaystyle \sum a \cdot x^n<br>$$<br>所以，运算中的单个结果一定是<br>$$<br>a \cdot x^n<br>$$<br>因此，我构建了一个类名为<code>Unit</code>，还有一个类名为<code>Poly</code>，用来处理单项式与多项式。而表达式、项、各种因子里面也有一个<code>toPoly</code>方法，用来把已经解析完成的表达式转换成多项式以供运算和输出。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>本次作业整体比较简单，除了删去多余的<code>^1</code>、乘号等，我还发现，可以尽量把正项放在前面，这样就可以省略一个<code>+</code>的长度。除此之外我没有想到什么可行的优化方案。事实也证明是这样，在强测中，我得到了100分。</p><h3 id="hack思路"><a href="#hack思路" class="headerlink" title="hack思路"></a>hack思路</h3><p>本次hack是比较<del>艰难</del>的，因为大家好像都没有什么bug。我在hack中多数依赖随机生成的测试点进行测试。只有一位同学的代码让我的评测机产生了报错，但是在将测试点复制到IDEA里面进行本地运行的时候却没有问题。直到后来我在观察这位同学的代码时，我才发现这个同学在处理输入的最后一个空白字符时会产生空指针，而我在复制测试点时只会复制到最后一个有效字符，确实是疏忽了。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h3><p>本次作业可谓是一个滑铁卢。在最开始设计的时候，我没有想到什么特别清晰的处理方法。最开始时，我试图使用字符串替换递推函数的方法，中间使用正则表达式来匹配。但是经过了一段时间的努力之后，我发现这样的做法存在着很大的弊端。于是后来，在和朋友们交流之后，我重新构建了递推函数的部分，先使用<strong>静态方法</strong>把定义式解析后，记录下对应位置的形参，然后在递推函数因子的<code>toPoly</code>方法里面，将形参和实参进行替换并计算。整体的思路是比较清晰的，但是因为时间原因，也没有进行完整的、足够的测试，最终少考虑了很多情况，在强测中得到了比较低的分数。</p><p>但是上次的设计思路依旧可取，不过形式需要转换一下，毕竟加入了新的三角函数等。然而在合并同类项的时候，我的设计整体比较奇怪</p><p><img src="/img/OO-Unit1/Unit.png" alt="Unit"></p><p>如图，明明<code>Poly</code>是由<code>Unit</code>组成的，但是<code>Unit</code>的成员里面却有着<code>Poly</code>，导致我在判断两个三角函数表达式是否相等时出了点问题，我重写了几次<code>hashCode</code>方法效果都不理想，最后干脆直接<code>toString</code>比较字符串了，效果居然还不错，但是在遇到一些刻意的不同形式的等价表达式，这种判断方法就不够用了。</p><h3 id="debug思路"><a href="#debug思路" class="headerlink" title="debug思路"></a>debug思路</h3><p>本次作业最主要的问题是情况考虑的不周到，忽视了递推函数中参数为三角函数因子的情况。所以在最终的debug过程中，我做的最多的其实是补充<code>if - else</code>分支，解决被忽视的情况。另外，我还更改了上次作业遗留的问题。在上次作业中，如果在表达式开头或者<code>(</code>之后直接跟了一个负号，我会主动添加一个0，把它改编成<code>0-</code>但是这样存在问题，如果函数因子为一个负常数，会导致这个负常数变成了一个表达式，进而解析就会出现问题，所以最后是把解析常数因子的部分修改成可以判断负号了。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h3><p>设计思路依然延续上两次作业的架构，新增了求导因子和普通函数因子。普通函数因子仅在最初定义时和递推函数有所不同，所以其实可以再把二者定义一个接口，把方法再精炼一下。</p><p>求导的实现也是使用了递归的思路，我把求导的方法添加到了<code>Factor</code>接口里面，同时也添加了<code>clone</code>方法，实现深克隆，避免修改原来实例化了的类。</p><h3 id="debug思路-1"><a href="#debug思路-1" class="headerlink" title="debug思路"></a>debug思路</h3><p>经过了上一次作业的痛苦教训，我尽力考虑周全了所有的情况，然而在一个不起眼的地方，我失误将返回的类定义为了<code>Expr</code>类。然而在我的处理中，处于内层的表达式都应当使用<code>SubExpr</code>类，所以当出现递推函数调用普通函数进行定义的时候，会产生参数替换失败的情况，也就是<code>f&#123;1&#125; = g(h(x^2))</code>这样的情况，我会解析成<code>f&#123;1&#125; = g(h(x))</code>，产生了一些bug，使我强测失去了一点分数。</p><h3 id="hack思路-1"><a href="#hack思路-1" class="headerlink" title="hack思路"></a>hack思路</h3><p>在hack开放之前，我先列下了一众大家可能会忽视的输入形式，比如函数嵌套调用、对三角函数嵌套求导等，然后人工捏了很多压力测试点，在hack开放后，对整个房间里的所有代码进行同步测试，最后确实发现了很多错误。</p><h2 id="可能的迭代需求"><a href="#可能的迭代需求" class="headerlink" title="可能的迭代需求"></a>可能的迭代需求</h2><p>可以发现，有很多的表达式形式都没有考虑到，比如指数函数、对数函数等等。以指数函数为例。两个底数相同的指数函数在相乘的时候，其底数不变、指数相加，那么在多项式乘法的方法里就要增加对指数函数相乘的处理：</p><ol><li>判断底数是否相同</li><li>将指数进行相加</li></ol><p>对数函数的处理也是类似的。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>本次作业我没有做特别多的优化，主要的优化在三角函数特殊值判断上面，比如运算中出现sin(0)，cos(0)等等，另外我尝试做了一下cos^2+sin^2的优化，不过只能在比较简单的条件下进行判断。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本次作业确实让我体会到了面向对象编程的奇妙之处。荣文戈老师的理论课也让我启发颇多。封装、多态的思想确实是面向对象的重要特点，也是面向对象编程有趣的地方。表达式的解析、递归下降，把每一项任务逐步下放到每个类中，每个类不向外界展示自己的“隐私”，让代码的运行变得清晰而有迹可循。</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>对于课程未来的方向，我觉得可以适当给予更多的时间以供大家对自己的架构进行更充足的优化，对自己的代码予以更充分的检查。另外，建议课程开展一个类似额外补充的项目，指导大家如何搭建属于自己的评测机，可以给一些合理的数据生成思路等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab1_实验报告</title>
      <link href="/2025/03/28/OS-Lab1/OS-Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/28/OS-Lab1/OS-Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h2><blockquote><p>在阅读 附录中的编译链接详解 以及本章内容后，尝试分别使用实验环境中<br>的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有<br>mips-linux-gnu- 前缀，如 mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编<br>译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p></blockquote><p>指导书中提到的objdump指令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>-D</code>表示：反汇编（Disassemble）那些预计包含指令的<strong>所有</strong>节区。</li><li><code>-S</code>表示：在反汇编输出中，尽可能地将源代码（如果编译时包含了调试信息，通常是使用 gcc -g 编译）与汇编代码交错显示。这对于理解某段汇编代码对应哪行 C&#x2F;C++ 源代码非常有帮助。通常需要与<code>-d</code>或<code>-D</code>一起使用。</li><li><code>-d</code>表示：反汇编那些预计包含指令的<strong>代码</strong>节区。</li></ul><p>首先，编写一个简单的程序<code>helloworld.c</code>，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>mips-linux-gnu-gcc -E helloworld.c &gt; temp</code>命令，只进行预处理，不进行编译和操作，找到文件末尾的位置，如图所示</p><p><img src="/img/OS-Lab1/preprocessing.png" alt="预处理"></p><p>预处理只不过是将头文件展开，替换成相应的代码，并没有任何编译和链接</p><p>依次执行下面两个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -c helloworld.c</span><br><span class="line">mips-linux-gnu-objdump -DS helloworld.o &gt; temp</span><br></pre></td></tr></table></figure><p>这两个命令分别是针对MIPS架构的交叉编译和反汇编操作</p><p>第一个命令是使用交叉编译器<code>mips-linux-gun-gcc</code>对<code>helloworld.c</code>文件进行编译，最终会生成目标文件<code>helloworld.o</code><br>第二个命令是使用<code>mips-linux-gnu-objdump</code>工具对目标文件<code>helloworld.o</code>进行反汇编，并将结果输出到<code>temp</code>中</p><p>最终结果如图</p><p><img src="/img/OS-Lab1/disassemble.png" alt="反汇编"></p><p>我们发现反汇编的结果中包含了源代码中定义的变量和函数</p><p>再执行下面两个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -o helloworld helloworld.c</span><br><span class="line">mips-linux-gnu-objdump -DS helloworld &gt; temp</span><br></pre></td></tr></table></figure><p>这两个命令是用于编译和反汇编 MIPS 架构程序的操作</p><p>第一个命令是使用交叉编译器<code>mips-linux-gun-gcc</code>对<code>helloworld.c</code>文件进行编译，生成可执行文件<code>helloworld</code><br>第二个命令是使用<code>mips-linux-gnu-objdump</code>工具对名为<code>helloworld</code>的可执行文件进行反汇编，并将反汇编结果输出到<code>temp</code>中</p><p><img src="/img/OS-Lab1/disassemble2.png" alt="反汇编2"></p><p>我们发现<code>main</code>函数被分配到了<code>00400650</code>的地址上</p><p>查阅相关资料后，我们知道：<br>如果只编译不链接</p><ol><li>生成目标文件（.o 文件），包含了编译后的机器代码和符号表信息，但还没有进行符号解析和地址重定位</li><li>如果涉及多个源文件，每个源文件都会生成对应的目标文件，但它们并未合并在一起</li></ol><p>编译并连接</p><ol><li>将各个目标文件连接在一起，解析符号引用，填充地址空间，并生成最终的可执行文件</li><li>在链接过程中，可能还会包含库文件、共享对象等，以及进行符号解析和地址重定位</li></ol><h2 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h2><blockquote><p>思考下述问题：</p><ul><li>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文<br>件。<blockquote><ul><li>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚<br>才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf<br>-h，并阅读 tools&#x2F;readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</li></ul></blockquote></li></ul></blockquote><p>运行<code>./tools/readelf/readelf ./target/mos</code>指令，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:0x0</span><br><span class="line">1:0x80010000</span><br><span class="line">2:0x80011cc0</span><br><span class="line">3:0x80011cd8</span><br><span class="line">4:0x80011cf0</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br></pre></td></tr></table></figure><p>我们得到了一系列的地址信息。但当我们用readelf程序去解析自身，却发现无法成功。这是因为我们编写的 readelf 程序仅支持解析<strong>32</strong>位 ELF 文件，而程序自身实际上是一个<strong>64</strong>位的 ELF 文件。</p><p>我们用<code>readelf -h</code>命令分别对<code>hello</code>和<code>readelf</code>文件进行头部信息解析。<code>hello</code>文件结果显示为<code>ELF32</code>，而<code>readelf</code>文件则显示为<code>ELF64</code></p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p>本次实验主要分为内核初始化阶段的底层配置和用户功能模块开发两个部分。在系统启动环节中，我们重点进行了内核地址空间的重新规划与启动流程的汇编级实现。这需要结合工程中的多维度技术文档，特别是通过解析内存映射示意图来修正链接脚本(kernel.lds)中的段地址参数，同时需要深入理解平台相关的宏定义体系，才能准确完成start.S中关键寄存器的初始化配置。虽然这部分基础代码量不大，但涉及到底层硬件与编译工具链的深度协同，需要建立完整的地址空间映射认知</p><p>在功能开发层面，实验包含两个特色模块的实现。首先是类readelf工具的核心功能仿真，虽然需要补全的代码片段有限，但整个工程架构涉及ELF文件格式解析的完整处理流程。为此必须仔细研读工程中预定义的节头表、程序头表等数据结构，并理解各字段在二进制解析过程中的动态填充机制。其次是内核级日志输出系统printk的完善，该任务虽然只需在现有框架内补充少量格式化处理逻辑，但要真正掌握其设计精髓，需要通盘分析可变参数处理机制、字符缓冲管理策略以及终端驱动接口的调用层级。特别值得注意的是，三个关联文件之间的数据流向和函数调用关系构成了完整的输出处理链条，这对理解操作系统内核的模块化设计思想具有重要价值</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>这次实验，我们整体的工作量并不是很大，难度也不高。但是比较重要的一点是我们要仔细阅读给出的代码，把握细节。把架构理清楚，代码的编写和补全就很轻松了。在补全代码的同时，我也学到了很多更有趣的c代码编写方式，也算是给我带来了更高端的代码编写细则</p><h1 id="原创说明"><a href="#原创说明" class="headerlink" title="原创说明"></a>原创说明</h1><p>本次实验报告参考了<a href="https://buaaczx.github.io/posts/20240712-os-lab1/">czx学长</a>和<a href="https://yanna-zy.github.io/2023/03/19/BUAA-OS-1/">zy学姐</a>的博客</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0_实验报告</title>
      <link href="/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h2><p>执行<code>git status &gt; Untracked.txt</code>，是查询当前<code>README.txt</code>的文件状态，并将其记录在<code>Untracked.txt</code>文件中。后续两个命令同理。</p><p>执行完<code>cat Untracked.txt</code>后，显示出<code>未跟踪的文件</code>，说明文件刚刚新建的时候，其处于未跟踪的状态；执行<code>cat Stage.txt</code>后，显示出<code>要提交的变更</code>，说明修改了文件，并使用<code>add</code>命令之后，文件处于暂存的状态；执行<code>cat Modified.txt</code>之后，显示出<code>尚未暂存以备提交的变更</code>，说明文件再被修改之后，处于被修改状态。</p><h2 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h2><p>add the file 对应的是git中的<code>git add</code>命令</p><p>stage the file 对应的也是git中的<code>git add</code>命令</p><p>commit 对应的是git中的<code>git commit</code>命令</p><h2 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h2><ol><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm --cached hello.txt</code></li></ol><h2 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h2><p>第一次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture1.png" alt="图片1"></p><p>第二次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture2.png" alt="图片2"></p><p>第三次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture3.png" alt="图片3"></p><p>第四次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture4.png" alt="图片4"></p><h2 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h2><p>执行<code>echo first</code>后如图</p><p><img src="/img/OS-Lab0/picture5.png" alt="图片5"></p><p>执行<code>echo second &gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture6.png" alt="图片6"></p><p>执行<code>echo third &gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture7.png" alt="图片7"></p><p>执行<code>echo forth &gt;&gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture8.png" alt="图片8"></p><h2 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h2><p><code>command</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash                                                              <span class="built_in">touch</span> <span class="built_in">test</span></span></span><br><span class="line">echo &#x27;echo Shell Start...&#x27; &gt; test</span><br><span class="line">echo &#x27;echo set a = 1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;a=1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set b = 2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;b=2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set c = a+b&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;c=$[$a+$b]&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo c = $c&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save c to ./file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $c&gt;file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save b to ./file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $b&gt;file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save a to ./file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $a&gt;file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file1 file2 file3 to file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file1&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file2&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file3&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file4 to ./result&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file4&gt;&gt;result&#x27; &gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><code>echo echo Shell Start</code>直接把<code>echo Shell Start</code>作为字符串输出；</li><li><code>echo (反顿号)echo Shell Start(反顿号)</code>是将<code>echo Shell Start</code>的<strong>输出</strong>作为外层echo的输入，所以会输出<code>Shell Start</code>；</li><li><code>echo echo $c&gt;file1</code>直接把<code>echo $c&gt;file</code>作为字符串输出；</li><li><code>echo (反顿号)echo $c&gt;file1(反顿号)</code>是将<code>echo $c&gt;file1</code>的<strong>输出</strong>作为外层echo的输入，所以会直接输出<code>$c&gt;file1</code>；</li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p><img src="/img/OS-Lab0/difficulty.png" alt="实验难点"></p><p>这里借用一下Hyggge学长的图，我个人认为写的非常好，我在进行线上实验的时候也注意到了这些难点，也是我经常在实验过程中回头去看指导书的地方。</p><p>在我自己的感觉里，我对<code>awk</code>命令和<code>grep</code>命令比较迷惑，也是看了很多攻略。其中<code>grep</code>命令的正则表达式和<code>java</code>的正则表达式不太一样，还得注意。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>对于计算机小白的我来说，刚开始接触命令行还是在大二上研究计组的时候。当初跟着同学里的大佬，在研究自动化测试的时候，慢慢开始接触命令行，学会用命令行解析、比对。当初确实感觉，相对图形化界面，命令行的一个极大的优点就是简洁。</p><p>当然，CLI对于计算机小白的我还是很有挑战性的。在刚开始使用CLI的时候，面对多种多样的指令、参数，我总是记不住它们的功能，写着写着还要重新去翻指导书，后来慢慢的才习惯了。</p><p>道阻且长，行则将至！诸君一起努力！</p><h1 id="原创说明"><a href="#原创说明" class="headerlink" title="原创说明"></a>原创说明</h1><p>本实验报告参考了Hyggge学长的<a href="https://hyggge.github.io/2022/03/21/os/os-lab0-shi-yan-bao-gao/">博客</a></p><p>另外致谢我的舍友風船同学，在学习过程中给了我很多帮助和解惑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2025/01/17/2024-1-17/"/>
      <url>/2025/01/17/2024-1-17/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>你好，当你看到这段文字的时候，证明我已经成功搭建出了自己的blog，真是<del>十分甚至九分</del>的感动口牙！<br>今后我也会多多在这个blog上分享自己的学习心得、游戏心得、生活琐事等等！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' fill='%23F2A3FE' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e1cda6,      #d8b75d,      #66afd4,      #6d6df0,      #db92d5    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    animation: Gradient 10s ease infinite !important;  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(222, 143, 234);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;  }    #cursor.hidden {    opacity: 0;  }    #cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);  }    #cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);  }  :root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);  }    /* 文章页、归档页、普通页面 */  div#post,  div#page,  div#archive {    background: var(--trans-light);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;  }    /* 导航栏 */  #page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    -webkit-backdrop-filter: var(--backdrop-filter);            backdrop-filter: var(--backdrop-filter);  }    [data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;  }    /* 夜间模式遮罩 */  [data-theme="dark"] #recent-posts > .recent-post-item,  [data-theme="dark"] #aside-content .card-widget,  [data-theme="dark"] div#post,  [data-theme="dark"] div#archive,  [data-theme="dark"] div#page {    background: var(--trans-dark);  }      /* 夜间模式页脚页头遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }    /* 阅读模式 */  .read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;  }  .read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;  }    /* 夜间模式下的阅读模式 */  [data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  [data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  .pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 4px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 7rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden}.pace-inactive .pace-progress {    opacity: 0;    transition: .3s ease-in}.pace .pace-progress {    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    /* linear-gradient(to right, #3494e6, #ec6ead) */    background: linear-gradient(to right, #43cea2, #3866ca);    animation: gradient 2s ease infinite;    background-size: 200%}.pace.pace-inactive {    opacity: 0;    transition: .3s;    top: -8px}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  animation: ccc 5s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@keyframes ccc {  0% {    transform: rotate(0deg);  }  to {    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #4953da;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #ea73f8;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ac3fff;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #55f8e0;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #27a20b;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #b1ad77;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: #0080ff;}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: #0080ff;  animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/snow.js"/>
      <url>/js/snow.js</url>
      
        <content type="html"><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    // 移动端不显示} else {    document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');    window && (() => {        let e = {            flakeCount: 50, // 雪花数目            minDist: 150,   // 最小距离            color: "255, 255, 255", // 雪花颜色            size: 1.5,  // 雪花大小            speed: .5,  // 雪花速度            opacity: .7,    // 雪花透明度            stepsize: .5    // 步距        };        const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {            window.setTimeout(e, 1e3 / 60)        }            ;        window.requestAnimationFrame = t;        const i = document.getElementById("snow"),            n = i.getContext("2d"),            o = e.flakeCount;        let a = -100,            d = -100,            s = [];        i.width = window.innerWidth,            i.height = window.innerHeight;        const h = () => {            n.clearRect(0, 0, i.width, i.height);            const r = e.minDist;            for (let t = 0; t < o; t++) {                let o = s[t];                const h = a,                    w = d,                    m = o.x,                    c = o.y,                    p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));                if (p < r) {                    const e = (h - m) / p,                        t = (w - c) / p,                        i = r / (p * p) / 2;                    o.velX -= i * e,                        o.velY -= i * t                } else                    o.velX *= .98,                        o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),                        o.velX += Math.cos(o.step += .05) * o.stepSize;                n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",                    o.y += o.velY,                    o.x += o.velX,                    (o.y >= i.height || o.y <= 0) && l(o),                    (o.x >= i.width || o.x <= 0) && l(o),                    n.beginPath(),                    n.arc(o.x, o.y, o.size, 0, 2 * Math.PI),                    n.fill()            }            t(h)        }            , l = e => {                e.x = Math.floor(Math.random() * i.width),                    e.y = 0,                    e.size = 3 * Math.random() + 2,                    e.speed = 1 * Math.random() + .5,                    e.velY = e.speed,                    e.velX = 0,                    e.opacity = .5 * Math.random() + .3            }            ;        document.addEventListener("mousemove", (e => {            a = e.clientX,                d = e.clientY        }        )),            window.addEventListener("resize", (() => {                i.width = window.innerWidth,                    i.height = window.innerHeight            }            )),            (() => {                for (let t = 0; t < o; t++) {                    const t = Math.floor(Math.random() * i.width)                        , n = Math.floor(Math.random() * i.height)                        , o = 3 * Math.random() + e.size                        , a = 1 * Math.random() + e.speed                        , d = .5 * Math.random() + e.opacity;                    s.push({                        speed: a,                        velX: 0,                        velY: a,                        x: t,                        y: n,                        size: o,                        stepSize: Math.random() / 30 * e.stepsize,                        step: 0,                        angle: 180,                        opacity: d                    })                }                h()            }            )()    }    )();}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = '見て見て!!!';    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = 'Timotei————';    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
