<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo博客butterfly主题美化教程</title>
      <link href="/2025/07/15/butterfly%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/hexo%E5%8D%9A%E5%AE%A2butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
      <url>/2025/07/15/butterfly%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/hexo%E5%8D%9A%E5%AE%A2butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>写在前面：</strong></p><ol><li>博客魔改有风险，建议在修改代码时，将原代码注释而不是删除</li><li>鉴于每个人的根目录名称都不一样，本帖<strong>博客根目录</strong>一律以 <code>[BlogRoot]</code> 指代</li><li>因为<code>.pug</code>、<code>.styl</code>和<code>.yml</code>文件对于缩进的要求较为严格，故建议大家使用 <code>VS Code</code>进行修改</li><li>本帖的部分代码以<strong>diff代码块</strong>标识，在修改时别忘记删去前面的 <code>+</code> 和 <code>-</code> 符号</li></ol></blockquote><h2 id="网站恶搞标题"><a href="#网站恶搞标题" class="headerlink" title="网站恶搞标题"></a>网站恶搞标题</h2><h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p><img src="/img/butterfly/title_pre.png"></p><p>在未选中该网页时，其呈现出这样的内容</p><p><img src="/img/butterfly/title_after.png"></p><p>在选中该网页的一段时间内，其呈现出这样的内容，之后恢复正常</p><h4 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h4><ol><li><p>新建文件 <code>[BlogRoot]\source\js\title.js</code>，写入以下内容：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态标题</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OriginTitile</span> = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span>) &#123;</span><br><span class="line">    <span class="comment">//离开当前页面时标签显示内容</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;見て見て!!!&#x27;</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前页面时标签显示内容</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Timotei————&#x27;</span>;</span><br><span class="line">    <span class="comment">//两秒后变回正常标题</span></span><br><span class="line">    titleTime = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title class_">OriginTitile</span>;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>别忘了在主题配置文件里面引入该内容：</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line"><span class="addition">+    - &lt;script async src=&quot;/js/title.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>最后重启该项目（该步骤以后不再赘述）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure></li></ol><h2 id="头像呼吸灯"><a href="#头像呼吸灯" class="headerlink" title="头像呼吸灯"></a>头像呼吸灯</h2><h4 id="效果预览-1"><a href="#效果预览-1" class="headerlink" title="效果预览"></a>效果预览</h4><p><img src="/img/butterfly/avatar_breathlight.png"></p><p>在头像周围加上一圈白色的呼吸灯</p><h4 id="修改方式-1"><a href="#修改方式-1" class="headerlink" title="修改方式"></a>修改方式</h4><p>这个呼吸灯可以通过<code>js</code>实现，也可以通过<code>css</code>实现。使用<code>css</code>实现的性能会好一点。所以可以在 <code>[BlogRoot]\source\css\custom.css</code>里面添加如下代码（没有就自己新建一个）。其中关于颜色、时间的部分大家都可以按照自己的喜好来调节。原理挺简单的，就是关键帧之间通过某个插值方法连续变样式而已，会这一个你就会DIY各种高大上的动画啦~</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头像呼吸灯 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-class">.avatar-img</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: huxi_light <span class="number">4s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.avatar-img</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: huxi_dark <span class="number">4s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> huxi_light &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> huxi_dark &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目即可看到效果。</p><h2 id="文章页顶波浪线"><a href="#文章页顶波浪线" class="headerlink" title="文章页顶波浪线"></a>文章页顶波浪线</h2><h4 id="效果预览-2"><a href="#效果预览-2" class="headerlink" title="效果预览"></a>效果预览</h4><p><img src="/img/butterfly/waves.png"></p><p>在文章封面的底部加上一层动态海浪效果，颜色可以自己调</p><h4 id="修改方式-2"><a href="#修改方式-2" class="headerlink" title="修改方式"></a>修改方式</h4><ol><li><p>修改 <code>[BlogRoot]\themes\butterfly\layout\includes\header\index.pug</code>文件，大概位置在33行</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if top_img !== false</span><br><span class="line">  if is_post()</span><br><span class="line">    include ./post-info.pug</span><br><span class="line"><span class="addition">+   section.main-hero-waves-area.waves-area</span></span><br><span class="line"><span class="addition">+     svg.waves-svg(xmlns=&#x27;http://www.w3.org/2000/svg&#x27;, xlink=&#x27;http://www.w3.org/1999/xlink&#x27;, viewBox=&#x27;0 24 150 28&#x27;, preserveAspectRatio=&#x27;none&#x27;, shape-rendering=&#x27;auto&#x27;)</span></span><br><span class="line"><span class="addition">+       defs</span></span><br><span class="line"><span class="addition">+         path#gentle-wave(d=&#x27;M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z&#x27;)</span></span><br><span class="line"><span class="addition">+       g.parallax</span></span><br><span class="line"><span class="addition">+         use(href=&#x27;#gentle-wave&#x27;, x=&#x27;48&#x27;, y=&#x27;0&#x27;)</span></span><br><span class="line"><span class="addition">+         use(href=&#x27;#gentle-wave&#x27;, x=&#x27;48&#x27;, y=&#x27;3&#x27;)</span></span><br><span class="line"><span class="addition">+         use(href=&#x27;#gentle-wave&#x27;, x=&#x27;48&#x27;, y=&#x27;5&#x27;)</span></span><br><span class="line"><span class="addition">+         use(href=&#x27;#gentle-wave&#x27;, x=&#x27;48&#x27;, y=&#x27;7&#x27;)</span></span><br><span class="line">    #post-top-cover</span><br><span class="line">      img#post-top-bg(class=&#x27;nolazyload&#x27; src=bg_img)</span><br><span class="line">  else if is_home()</span><br><span class="line">    #site-info</span><br><span class="line">      h1#site-title=site_title</span><br><span class="line">      if theme.subtitle.enable</span><br></pre></td></tr></table></figure><p> 注意看好缩进</p></li><li><p>然后在 <code>[BlogRoot]\source\css\custom.css</code>里面添加如下内容</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 波浪css */</span></span><br><span class="line"><span class="selector-class">.main-hero-waves-area</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">11px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.waves-area</span> <span class="selector-class">.waves-svg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Animation */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: move-forever <span class="number">25s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.55</span>, <span class="number">0.5</span>, <span class="number">0.45</span>, <span class="number">0.5</span>) infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">7s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#f7f9febd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">10s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#f7f9fe82</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">4s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">13s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#f7f9fe36</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">20s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#f7f9fe</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 黑色模式背景 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">7s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#18171dc8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">3s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">10s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#18171d80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">4s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">13s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#18171d3e</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.parallax</span> &gt; <span class="selector-tag">use</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">20s</span>;</span><br><span class="line">  <span class="attribute">fill</span>: <span class="number">#18171d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move-forever &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">90px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">85px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Shrinking for mobile*/</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.waves-area</span> <span class="selector-class">.waves-svg</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>css</code>里面的<code>fill</code>属性就是控制波浪颜色的，最好让其中一个颜色与背景颜色一致，不然的话看起来会很怪。</p></li><li><p>最后重启该项目即可。</p></li></ol><h2 id="添加fps显示"><a href="#添加fps显示" class="headerlink" title="添加fps显示"></a>添加fps显示</h2><h4 id="效果预览-3"><a href="#效果预览-3" class="headerlink" title="效果预览"></a>效果预览</h4><p><img src="/img/butterfly/FPS.png"></p><p>在页面的某个位置（我这里设置的是左下角），添加fps的显示，可以划阶段显示不同文字</p><h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><ol><li><p>新建文件 <code>[BlogRoot]\source\js\fps.js</code>，并写入如下代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;fpson&quot;</span>) == <span class="literal">undefined</span> || <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;fpson&quot;</span>) == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> rAF = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> ||</span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> ||</span><br><span class="line">            <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">                <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="keyword">var</span> frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> allFrameCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">var</span> lastFameTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">var</span> loop = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">var</span> fs = (now - lastFameTime);</span><br><span class="line">        <span class="keyword">var</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">1000</span> / fs);</span><br><span class="line"></span><br><span class="line">        lastFameTime = now;</span><br><span class="line">        <span class="comment">// 不置 0，在动画的开头及结尾记录此值的差值算出 FPS</span></span><br><span class="line">        allFrameCount++;</span><br><span class="line">        frame++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now &gt; <span class="number">1000</span> + lastTime) &#123;</span><br><span class="line">            <span class="keyword">var</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>((frame * <span class="number">1000</span>) / (now - lastTime));</span><br><span class="line">            <span class="keyword">if</span> (fps &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:#bd0000&quot;&gt;卡成ppt😰&lt;/span&gt;`</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fps &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:red&quot;&gt;电竞级帧率😖&lt;/span&gt;`</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fps &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:orange&quot;&gt;有点难受😨&lt;/span&gt;`</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fps &lt; <span class="number">35</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:#9338e6&quot;&gt;不太流畅🙄&lt;/span&gt;`</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fps &lt;= <span class="number">45</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:#08b7e4&quot;&gt;还不错哦😁&lt;/span&gt;`</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> kd = <span class="string">`&lt;span style=&quot;color:#39c5bb&quot;&gt;十分流畅🤓&lt;/span&gt;`</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fps&quot;</span>).<span class="property">innerHTML</span> = <span class="string">`FPS:<span class="subst">$&#123;fps&#125;</span> <span class="subst">$&#123;kd&#125;</span>`</span>;</span><br><span class="line">            frame = <span class="number">0</span>;</span><br><span class="line">            lastTime = now;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">rAF</span>(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">loop</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fps&quot;</span>).<span class="property">style</span> = <span class="string">&quot;display:none!important&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>[BlogRoot]\source\css\custom.css</code>中加入如下代码，我这里就是让这个显示在左下角，你可以自己指定位置，其中 <code>backdrop-filter</code>过滤器也可以自己指定，也可以不要</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 帧率检测 */</span></span><br><span class="line"><span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="comment">/* 指定位置 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.85</span>);</span><br><span class="line">  <span class="attribute">backdrop-filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.72</span>);</span><br><span class="line">  <span class="attribute">backdrop-filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.butterfly.yml</code>文件中加入如下代码</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject: </span><br><span class="line">  head: </span><br><span class="line"><span class="addition">+    - &lt;span id=&quot;fps&quot;&gt;&lt;/span&gt; # 帧率检测</span></span><br><span class="line">  bottom: </span><br><span class="line"><span class="addition">+    - &lt;script async src=&quot;/js/fps.js&quot;&gt;&lt;/script&gt; # 帧率检测</span></span><br></pre></td></tr></table></figure></li><li><p>重启项目看看有没有出现帧率块</p></li></ol><h2 id="右边按钮阅读进度"><a href="#右边按钮阅读进度" class="headerlink" title="右边按钮阅读进度"></a>右边按钮阅读进度</h2><h4 id="效果预览-4"><a href="#效果预览-4" class="headerlink" title="效果预览"></a>效果预览</h4><p><img src="/img/butterfly/progress.png"></p><p>其实是把一键回到页顶给修改了一下。当鼠标没有悬停在这个按钮上的时候，它会显示当前文章的阅读进度；当鼠标悬停在上面的时候，它会显示一个上箭头，点击即可回到页顶</p><h4 id="修改方法-1"><a href="#修改方法-1" class="headerlink" title="修改方法"></a>修改方法</h4><blockquote><p>其实实现原理也比较简单，我们只要把 <code>被顶部卷去的高度/（页面总高度 - 可视高度）</code>，就能算出百分比啦！之所以减去可视高度，是因为当我们在滑倒最底部的时候，可以看出 <code>页面高度 = 被卷去的高度 + 可视高度</code></p></blockquote><ol><li><p>修改文件 <code>[BlogRoot]\themes\butterfly\layout\includes\rightside.pug</code>，在最下面插入如下两行代码</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button#go-up(type=&quot;button&quot; title=_p(&quot;rightside.back_to_top&quot;))</span><br><span class="line">  i.fas.fa-arrow-up</span><br><span class="line"><span class="addition">+span#percent 0</span></span><br><span class="line"><span class="addition">+     span %</span></span><br></pre></td></tr></table></figure></li><li><p>新建文件 <code>[BlogRoot]\source\js\readPercent.js</code>，加入如下代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当窗口滚动时，执行 percent 函数</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = percent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面百分比函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">percent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// --- 计算滚动百分比 ---</span></span><br><span class="line">  <span class="keyword">let</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">window</span>.<span class="property">pageYOffset</span>;</span><br><span class="line">  <span class="keyword">let</span> scrollHeight = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>, <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span>) - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Math</span>.<span class="title function_">round</span>(scrollTop / scrollHeight * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接通过 class 获取箭头元素，更可靠</span></span><br><span class="line">  <span class="keyword">const</span> arrow = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#go-up .fa-arrow-up&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> percentEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#percent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果找不到元素，就直接退出，防止报错</span></span><br><span class="line">  <span class="keyword">if</span> (!arrow || !percentEl) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result &gt;= <span class="number">95</span>) &#123;</span><br><span class="line">    arrow.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    percentEl.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arrow.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    percentEl.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    <span class="comment">// 在更新数字的同时，加上 &#x27;%&#x27; 号</span></span><br><span class="line">    percentEl.<span class="property">innerText</span> = result + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建文件 <code>[BlogRoot]\source\css\readPercent.css</code>，写入如下代码</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回顶部 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-id">#go-up</span> <span class="selector-id">#percent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-id">#go-up</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标滑动到按钮上时显示返回顶部图标 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-id">#go-up</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-id">#go-up</span><span class="selector-pseudo">:hover</span> <span class="selector-id">#percent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后记得引入一下js和css文件</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line"><span class="addition">+    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/readPercent.css&quot;&gt;</span></span><br><span class="line">  bottom:</span><br><span class="line"><span class="addition">+    - &lt;script defer data-pjax src=&quot;/js/readPercent.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>重启项目即可看到效果</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_challenge_shell_实验报告</title>
      <link href="/2025/06/25/OS-Lab6-challenge/%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/06/25/OS-Lab6-challenge/%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><p>本次实验旨在对 MOS 操作系统中现有的 Shell 进行功能扩展，使其从一个基础的命令解释器演进为一个功能更加完善、用户体验更佳的交互式程序。实验内容主要包括：</p><ol><li><strong>路径管理</strong>：引入当前工作目录（CWD）的概念，支持相对路径，并实现 <code>cd</code> 和 <code>pwd</code> 内置命令。</li><li><strong>环境变量</strong>：实现局部和全局环境变量的管理，包括 <code>declare</code>、<code>unset</code> 命令和 <code>$</code> 变量展开。</li><li><strong>输入与指令优化</strong>：实现指令自由输入、不带 <code>.b</code> 后缀指令、快捷键、历史指令、注释功能、</li><li><strong>指令条件执行</strong>：实现 Linux shell 中的 <code>&amp;&amp;</code> 和 <code>||</code>。</li><li><strong>更多指令</strong>：增加 <code>touch</code>, <code>mkdir</code>, <code>rm</code> 等常用文件系统操作命令和 <code>exit</code> 指令。</li><li><strong>追加重定向</strong>：实现了追加重定向功能</li></ol><p>限于篇幅，本报告并未给出全部修改的代码，仅给出了笔者认为比较关键，语言不能完全描述的部分代码。</p><h1 id="实验设计与实现"><a href="#实验设计与实现" class="headerlink" title="实验设计与实现"></a>实验设计与实现</h1><h2 id="1-支持相对路径与内置命令-cd、pwd"><a href="#1-支持相对路径与内置命令-cd、pwd" class="headerlink" title="1. 支持相对路径与内置命令 cd、pwd"></a><strong>1. 支持相对路径与内置命令 <code>cd</code>、<code>pwd</code></strong></h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a><strong>1.1 设计思路</strong></h3><p>为了支持相对路径，核心是为每个进程维护一个“当前工作目录”（CWD）的状态。</p><ol><li><strong>CWD 的存储</strong>：<ul><li>最佳方案是利用共享内存。我分配了一个固定的虚拟地址 <code>CWD_VA</code> (<code>0x7f000000</code>)，并将其映射为一个带有 <code>PTE_LIBRARY</code> 标志的共享页面。<code>PTE_LIBRARY</code> 确保了通过 <code>fork</code> 或 <code>spawn</code> 创建的子进程能自动继承这个页面的映射，从而共享 CWD 字符串。</li><li>在 Shell 启动时（<code>libmain</code> -&gt; <code>fsutil_init</code>），会检查该页面是否已映射。如果是第一个启动的 Shell，它会负责分配并初始化 CWD 为根目录 <code>/</code>。</li></ul></li><li><strong>路径解析</strong>：<ul><li>创建一个 <code>resolve_path</code> 函数，负责将用户输入的任何路径（绝对或相对）转换为一个唯一的、规范化的绝对路径。</li><li><code>normalize_path</code> 函数负责处理拼接后的路径，解析 <code>.</code> 和 <code>..</code>，并移除多余的 <code>/</code>，最终得到一个干净的绝对路径。这个绝对路径随后被传递给 <code>open</code>、<code>stat</code> 等底层系统调用。</li></ul></li><li><strong>内置命令实现</strong>：<ul><li><strong><code>cd</code></strong>：作为一个内置命令，<code>cd</code> 直接修改共享内存中的 CWD 字符串。它首先使用 <code>resolve_path</code> 解析目标路径，然后通过 <code>stat</code> 检查路径是否存在且为目录，验证通过后，更新 CWD。</li><li><strong><code>pwd</code></strong>：同样是内置命令，它直接读取共享内存中的 CWD 字符串并打印到标准输出。</li></ul></li></ol><h3 id="1-2-关键代码"><a href="#1-2-关键代码" class="headerlink" title="1.2 关键代码"></a><strong>1.2 关键代码</strong></h3><p><strong>CWD 共享与初始化 (<code>user/lib/fsutil.c</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个固定的虚拟地址用于存储CWD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CWD_VA 0x7f000000 </span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *current_working_directory;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fsutil_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指针指向我们的固定地址</span></span><br><span class="line">    current_working_directory = (<span class="type">char</span> *)CWD_VA;</span><br><span class="line">    <span class="comment">// 检查这个页面是否已经被映射。pageref &gt; 0 表示已映射。</span></span><br><span class="line">    <span class="comment">// 如果没有被映射，说明当前进程是第一个启动的进程（通常是 sh），</span></span><br><span class="line">    <span class="keyword">if</span> (pageref(current_working_directory) == <span class="number">0</span>) &#123;</span><br><span class="line">        syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)current_working_directory, PTE_D | PTE_LIBRARY);</span><br><span class="line">        <span class="comment">// 初始化CWD为根目录 &quot;/&quot;</span></span><br><span class="line">        <span class="built_in">strcpy</span>(current_working_directory, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>lib/libos.c</code> 中的 <code>libmain</code> 会在 <code>main</code> 函数执行前调用 <code>fsutil_init</code>，确保 CWD 机制就绪。</li><li><code>PTE_LIBRARY</code> 标志是实现父子进程共享 CWD 的关键。</li></ul><p><strong>路径解析 (<code>user/lib/fsutil.c</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将相对路径转换为绝对路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resolve_path</span><span class="params">(<span class="type">char</span> *resolved_path, <span class="type">const</span> <span class="type">char</span> *relative_path)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (relative_path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 已经是绝对路径</span></span><br><span class="line"><span class="built_in">strcpy</span>(resolved_path, relative_path);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 是相对路径，与CWD拼接</span></span><br><span class="line"><span class="built_in">strcpy</span>(resolved_path, current_working_directory);</span><br><span class="line"><span class="comment">// 只有当CWD不是根目录时，才在末尾添加&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(current_working_directory, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">strcat</span>(resolved_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcat</span>(resolved_path, relative_path);</span><br><span class="line">&#125;</span><br><span class="line">normalize_path(resolved_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个函数统一了路径处理的入口，所有文件操作（如 <code>open</code>, <code>stat</code>, <code>rm</code> 等）都调用它来获取绝对路径。</p></li><li><p><code>cd</code> 作为一个改变 Shell 自身状态的命令，必须在主 Shell 进程中直接执行，而不是 <code>fork</code> 一个子进程来执行。我的代码在 <code>sh.c</code> 的主循环中正确地处理了这一点。<code>pwd</code> 也可以这样处理，或者像现在一样在子进程中执行，因为它不改变 Shell 状态。</p></li></ul><h2 id="2-环境变量管理"><a href="#2-环境变量管理" class="headerlink" title="2. 环境变量管理"></a><strong>2. 环境变量管理</strong></h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a><strong>2.1 设计思路</strong></h3><ol><li><p><strong>数据结构</strong>：定义了一个 <code>Var</code> 结构体来存储单个变量，包括名称、值以及 <code>is_env</code>、<code>is_readonly</code> 等标志位。所有变量存储在一个全局数组 <code>shell_vars</code> 中。</p></li><li><p><strong>命令实现</strong>：</p><ul><li><code>declare</code>：解析 <code>-x</code>, <code>-r</code> 选项和 <code>NAME=VALUE</code> 格式。调用 <code>add_var</code> 函数。该函数会先用 <code>find_var</code> 查找变量。如果存在且非只读，则更新；如果不存在，则在 <code>shell_vars</code> 数组中找一个空位创建。</li><li><code>unset</code>：调用 <code>remove_var</code>，该函数会查找变量，如果存在且非只读，则将其从数组中移除。</li><li><code>$</code> 变量展开：在执行命令前，增加一个 <code>expand_vars</code> 阶段。该函数遍历命令行字符串，查找 <code>$</code> 符号，提取后面的变量名，用 <code>find_var</code> 查找其值，并将 <code>$</code> 和变量名替换为其值。</li></ul></li></ol><h3 id="2-2-关键代码"><a href="#2-2-关键代码" class="headerlink" title="2.2 关键代码"></a><strong>2.2 关键代码</strong></h3><p><strong>变量数据结构与管理 (<code>user/include/var.h</code>, <code>user/lib/var.c</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/var.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> value[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">    u_int is_env : <span class="number">1</span>;</span><br><span class="line">    u_int is_readonly : <span class="number">1</span>;</span><br><span class="line">    u_int is_used : <span class="number">1</span>;</span><br><span class="line">&#125; Var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Var shell_vars[MAX_VARS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/var.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_var</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, u_int is_env, u_int is_readonly)</span> &#123;</span><br><span class="line">    Var *var = find_var(name);</span><br><span class="line">    <span class="keyword">if</span> (var) &#123; <span class="comment">// 变量已存在</span></span><br><span class="line">        <span class="keyword">if</span> (var-&gt;is_readonly) &#123; <span class="comment">/* ... 错误处理 ... */</span> &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(var-&gt;value, value ? value : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ... 更新属性 ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 变量不存在</span></span><br><span class="line">        <span class="keyword">if</span> (num_shell_vars &gt;= MAX_VARS) &#123; <span class="comment">/* ... 错误处理 ... */</span> &#125;</span><br><span class="line">        <span class="comment">// ... 找空位并创建 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>declare</code> 命令处理 (<code>user/sh.c</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handle_declare</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    u_int is_env = <span class="number">0</span>, is_readonly = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ... 解析 -x, -r 选项 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析 NAME[=VALUE]</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="type">char</span> *name = argv[i];</span><br><span class="line">        <span class="type">char</span> *value = <span class="built_in">strchr</span>(name, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            *value = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 分割 name 和 value</span></span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (add_var(name, value, is_env, is_readonly) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量展开 (<code>user/sh.c</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">expand_vars</span><span class="params">(<span class="type">char</span> *in_buf, <span class="type">char</span> *out_buf, <span class="type">int</span> out_size)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p_in = in_buf;</span><br><span class="line">    <span class="type">char</span> *p_out = out_buf;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (*p_in &amp;&amp; p_out &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p_in == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            p_in++; <span class="comment">// 跳过 &#x27;$&#x27;</span></span><br><span class="line">            <span class="type">char</span> var_name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// ... 提取变量名 ...</span></span><br><span class="line">            </span><br><span class="line">            Var *v = find_var(var_name);</span><br><span class="line">            <span class="keyword">if</span> (v) &#123;</span><br><span class="line">                <span class="comment">// ... 将 v-&gt;value 拷贝到 out_buf ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *p_out++ = *p_in++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *p_out = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 循环中调用</span></span><br><span class="line">expand_vars(current_chunk_start, expanded_buf, <span class="keyword">sizeof</span>(expanded_buf));</span><br></pre></td></tr></table></figure><h2 id="3-输入指令优化"><a href="#3-输入指令优化" class="headerlink" title="3. 输入指令优化"></a><strong>3. 输入指令优化</strong></h2><h3 id="3-1-设计思路"><a href="#3-1-设计思路" class="headerlink" title="3.1 设计思路"></a><strong>3.1 设计思路</strong></h3><p>为了实现高级的行编辑功能，必须放弃简单的、带回显的 <code>read</code> 系统调用，转而使用更底层的、无回显的字符获取方式，并由 Shell 自己完全控制终端的回显和光标移动。</p><ol><li><p><strong>指令自由输入</strong>：</p><ol><li><strong>底层输入</strong>：使用 <code>syscall_cgetc()</code> 获取单个字符，该调用不阻塞且无回显。</li><li><strong>状态维护</strong>：在 <code>readline</code> 函数中，维护两个核心状态：<code>len</code>（当前输入缓冲区的总长度）和 <code>cursor_pos</code>（光标在缓冲区中的逻辑位置）。</li><li><strong>处理普通字符</strong>：接收到可打印字符时，在 <code>cursor_pos</code> 处将其插入缓冲区（需要移动后续字符），然后打印该字符，并使用 ANSI 转义序列重绘光标之后的内容，最后将光标移回正确位置。</li></ol></li><li><p><strong>不带 <code>.b</code> 后缀</strong>：在 <code>spawn</code> 函数中，当尝试执行一个程序时，如果直接 <code>spawn</code> 失败，并且程序名不以 <code>.b</code> 结尾，就为其拼接上 <code>.b</code> 后缀再尝试一次。</p></li><li><p><strong>快捷键</strong>：</p><ul><li><strong>方向键</strong>：它们是 ANSI 转义序列（如 <code>\x1b[A</code>）。<code>readline</code> 中有一个状态机来捕获这些序列。</li><li><strong>退格键</strong>：修改缓冲区和 <code>len</code>、<code>cursor_pos</code>，并向终端发送“退格-空格-退格”序列来擦除字符，然后重绘光标后的内容。</li><li><strong>Ctrl-A&#x2F;E&#x2F;K&#x2F;U&#x2F;W</strong>：每个快捷键都对应一套对缓冲区 <code>buf</code> 和 <code>len</code>、<code>cursor_pos</code> 的逻辑操作，以及一套相应的终端控制指令（如清屏 <code>\x1b[K</code>，光标移动 <code>\r</code>, <code>\x1b[nC</code>）来更新屏幕显示。</li></ul></li><li><p><strong>历史指令</strong>：使用一个全局数组 <code>history_lines</code> 存储历史命令。<code>load_history</code> 和 <code>add_to_history</code> 函数负责从 <code>/.mos_history</code> 文件中读写历史记录。</p></li><li><p>**注释 **：我设计了一个辅助函数 <code>find_and_split</code> 。这个函数负责从当前命令指针开始，查找第一个出现的有关字符。其中，<code>#</code> 被视为行尾，它会立即停止对当前命令块的解析。</p></li><li><p><strong>反引号替换</strong>：</p><ul><li>在变量展开之后、命令执行之前，增加一个反引号处理阶段。</li><li>该阶段遍历命令字符串，查找成对的 <code>`</code>。</li><li>对于每个 <code>`...`</code> 块，提取其中的子命令。</li><li>创建一个管道，子进程执行子命令后通过管道把执行后的结果传给父进程。</li></ul></li><li><p><strong>一行多指令</strong>：为了支持在一行中通过 <code>;</code> 分隔执行多个独立的命令，核心思路是将完整的命令行字符串分割成多个独立的命令块，然后按顺序依次执行。</p><ol><li><strong>命令块分割</strong>：在 <code>find_and_split</code> 当找到一个 <code>;</code> 时，它会将该位置的字符替换为 <code>\0</code>，从而有效地将一个长命令字符串“截断”成一个独立的命令块。同时，函数返回下一个命令块的起始位置。</li><li><strong>循环执行</strong>：在 <code>sh.c</code> 的 <code>main</code> 函数中，我设计了一个主 <code>while</code> 循环。这个循环不断地调用 <code>find_and_split</code> 来获取下一个命令块。获取到命令块后，就立即对其进行变量展开、反引号替换，并最终通过 <code>fork</code> 和 <code>runcmd</code>（或直接执行内置命令）来执行它。</li></ol><p> 通过这种“分割-执行”的循环模式，Shell 能够处理包含任意多个由 <code>;</code> 分隔的指令行。</p></li></ol><h3 id="3-2-关键代码"><a href="#3-2-关键代码" class="headerlink" title="3.2 关键代码"></a><strong>3.2 关键代码</strong></h3><p><strong>自由输入与快捷键 (<code>user/sh.c: readline</code>)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line"><span class="type">int</span> cursor_pos = <span class="number">0</span>; <span class="comment">// 光标在缓冲区中的逻辑位置</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;        <span class="comment">// 缓冲区中当前命令的长度</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> ((c = syscall_cgetc()) == <span class="number">0</span>) &#123; <span class="comment">// 无回显获取字符</span></span><br><span class="line">syscall_yield();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;\b&#x27;</span> || c == <span class="number">0x7f</span>) &#123; <span class="comment">// 退格键</span></span><br><span class="line"><span class="comment">// 实现回显擦除</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\x1b&#x27;</span>) &#123; <span class="comment">// ANSI转义序列 (箭头等)</span></span><br><span class="line"><span class="comment">// 根据转义序列判断快捷键类型并执行对应操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通字符</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c); <span class="comment">// 手动回显</span></span><br><span class="line">            <span class="comment">// ... 逻辑插入并重绘光标后内容 ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>find_and_split函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">find_and_split</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *op)</span> &#123;</span><br><span class="line"><span class="type">char</span> *p = s;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;&amp;&#x27;</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">*op = <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;|&#x27;</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">*op = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;;&#x27;</span>) &#123;</span><br><span class="line">*op = <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line">*op = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该函数负责查找命令中的 <code>&amp;&amp;</code>，<code>||</code>，<code>#</code> 和 <code>;</code></li></ul><h2 id="4-指令条件执行"><a href="#4-指令条件执行" class="headerlink" title="4. 指令条件执行"></a><strong>4. 指令条件执行</strong></h2><h3 id="4-1-设计思路"><a href="#4-1-设计思路" class="headerlink" title="4.1 设计思路"></a><strong>4.1 设计思路</strong></h3><p>我把 Shell 的主循环设计成了一个能处理复杂命令行的状态机。</p><ol><li><p>   <strong>命令分隔与执行</strong>：</p><ul><li><strong><code>;</code></strong>： <code>find_and_split</code> 来查找下一个命令分隔符（<code>&amp;&amp;</code>, <code>||</code>）。它将命令字符串在分隔符处用 <code>\0</code> 截断，形成一个个命令块。</li><li><strong><code>&amp;&amp;</code> 和 <code>||</code></strong>：主循环维护一个 <code>last_status</code> (上一个命令的退出码) 和 <code>should_run_next</code> (是否应执行下一个命令) 的状态。</li></ul></li><li><p><strong><code>exit</code> 返回状态</strong>：我修改了原有的 <code>exit()</code> 函数，使其能够支持获得命令执行的返回值。</p></li></ol><h2 id="5-更多指令"><a href="#5-更多指令" class="headerlink" title="5. 更多指令"></a><strong>5. 更多指令</strong></h2><h3 id="5-1-设计思路"><a href="#5-1-设计思路" class="headerlink" title="5.1 设计思路"></a><strong>5.1 设计思路</strong></h3><ol><li><strong><code>touch</code>, <code>mkdir</code>, <code>rm</code></strong>:<ul><li>这些命令都是独立的可执行程序 (<code>touch.c</code>, <code>mkdir.c</code>, <code>rm.c</code>)。</li><li>它们通过 <code>main</code> 函数的 <code>argc</code>, <code>argv</code> 解析命令行参数（如 <code>rm -rf</code>）。</li><li>内部调用相应的库函数（最终是系统调用）来完成操作：<ul><li><code>touch</code>: 使用 <code>open</code> 的 <code>O_CREAT</code> 标志。</li><li><code>mkdir</code>: 使用新增的 <code>fsipc_mkdir</code> -&gt; <code>serve_mkdir</code> -&gt; <code>file_create_dir</code> 流程。<code>-p</code> 选项通过递归调用 <code>mkdir_p</code> 实现。</li><li><code>rm</code>: <code>stat</code> 判断是文件还是目录。对文件调用 <code>remove</code>。对目录，如果带 <code>-r</code>，则递归遍历并删除内容，最后删除自身。</li></ul></li></ul></li><li><strong><code>exit</code></strong>:<ul><li>这是一个内置命令，因为它需要终止当前的 Shell 进程。</li><li><code>handle_exit</code> 解析可选的数字参数，然后调用 <code>syscall_exit(code)</code> 退出。</li></ul></li></ol><h2 id="6-实现追加重定向"><a href="#6-实现追加重定向" class="headerlink" title="6. 实现追加重定向"></a><strong>6. 实现追加重定向</strong></h2><h3 id="6-1-实现思路"><a href="#6-1-实现思路" class="headerlink" title="6.1 实现思路"></a><strong>6.1 实现思路</strong></h3><p><strong>追加重定向</strong>:</p><ul><li>在 <code>_gettoken</code> 中增加对 <code>&gt;&gt;</code> 的识别，返回一个特殊的 token。</li><li>在 <code>parsecmd</code> 中，为这个新的 token 增加一个 case。</li><li>当遇到 <code>&gt;&gt;</code> 时，使用 <code>open</code> 的 <code>O_WRONLY | O_CREAT | O_APPEND</code> 标志打开文件。<code>O_APPEND</code> 是关键，它告诉文件系统后续的 <code>write</code> 操作都在文件末尾进行。</li><li>在 <code>user/lib/fd.c</code> 的 <code>write</code> 函数中，也增加了对 <code>O_APPEND</code> 模式的检查，在每次写入前，先 <code>seek</code> 到文件末尾。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>本次实验成功地将 MOS 的 Shell 从一个简单的命令执行器，转变为一个具备现代 Shell 诸多核心功能的强大工具。通过实现CWD管理、环境变量、行编辑、历史命令、高级命令流控制等功能，不仅极大地提升了 MOS 的可用性和用户体验，更重要的是，在实践中深入理解了操作系统中进程状态管理、内存共享、IPC、文件系统交互等核心概念的底层实现细节。整个过程充满挑战，但也收获颇丰。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab6_实验报告</title>
      <link href="/2025/06/14/OS-Lab6/BUAA_OS_Lab6%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/06/14/OS-Lab6/BUAA_OS_Lab6%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab6-实验报告"><a href="#BUAA-OS-Lab6-实验报告" class="headerlink" title="BUAA_OS_Lab6 实验报告"></a>BUAA_OS_Lab6 实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</p></blockquote><p>修改如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 - 作为管道的写者 */</span></span><br><span class="line">        close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">        write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line">        close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程 - 作为管道的写者 */</span></span><br><span class="line">        close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">        read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line">        close(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端 */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user&#x2F;lib&#x2F;fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？ </p></blockquote><p>此前的<code>dup</code>函数是先映射文件描述符，再映射文件内容。如果在映射完文件描述符后，进程被中断，那么另一程序会错误的认为文件映射已经完成，产生错误。</p><h3 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h3><blockquote><p>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.macro CLI</span><br><span class="line">        mfc0    t0, CP0_STATUS</span><br><span class="line">        li      t1, (STATUS_CU0 | 0x1)</span><br><span class="line">        or      t0, t1</span><br><span class="line">        xor     t0, 0x1</span><br><span class="line">        mtc0    t0, CP0_STATUS</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，操作系统在进行系统调用的时候，进行了一个短暂的关中断，所以系统调用是原子操作</p><h3 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h3><blockquote><p>仔细阅读上面这段话，并思考下列问题</p><ul><li>按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</li></ul></blockquote><p>可以解决。先关闭缓冲区后，缓冲区的引用次数就发生了修改。此时，即使发生了中断，<code>pipe</code>也会阻止读写操作。<br>可以解决。先建立缓冲区，此时<code>pipe</code>就已经可以进行正常的读写功能了。</p><h3 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h3><blockquote><p>思考以下三个问题。</p><ul><li>认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。</li><li>回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。</li><li>回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？</li></ul></blockquote><ul><li>首先用户调用<code>user/lib/files.c</code>文件中的<code>open</code>函数，然后<code>open</code>函数调用了<code>fsipc</code>函数，这个函数会向文件系统发送一个请求，并等待返回的信息。文件系统中的<code>serve</code>函数会调用<code>file_open</code>函数来完成文件的打开操作，并返回返回值。</li><li>ELF文件中的段信息是通过<code>Elf32_Phdr</code>结构体数组来描述的，其中包含了各个段的类型、在文件中的偏移、在内存中的虚拟地址、大小等信息。对于<code>bss</code>段，虽然它在文件中不占据实际存储空间，但它在内存中有一个预期的大小，用于存放未初始化的全局变量和静态变量，这些变量默认值为0。</li><li>加载器遍历ELF文件的各个段并调用<code>elf_load_seg0()</code>处理各个段的时候，关键在于如何处理<code>sgsize</code>和<code>bin_size</code>之间的差异，也就是段在内存中的大小和段在文件中的大小之间的差异。如果段有实际的数据内容（<code>.text</code>或<code>.data</code>），<code>elf_load_seg()</code>会通过调用<code>load_icode_mapper()</code>将这些内容从文件复制到对应的虚拟内存位置；对于<code>bss</code>段，不断分配页面直到达到<code>sgsize</code>指定的大小，所以新分配的页面不会从文件中复制任何数据，保持其内容为全0，自然就被初始化为全 0。</li></ul><h3 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h3><blockquote><p>通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdin should be 0, because no file descriptors are open yet</span></span><br><span class="line"><span class="keyword">if</span> ((r = opencons()) != <span class="number">0</span>) &#123;</span><br><span class="line">    user_panic(<span class="string">&quot;opencons: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stdout</span></span><br><span class="line"><span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    user_panic(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>user/init.c</code>的代码片段。</p><h3 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h3><blockquote><p>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork一个子 shell，然后子 shell 去执行这条命令。</p><p>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么Linux 的 cd 命令是内部命令而不是外部命令？</p></blockquote><p><code>cd</code>命令用于改变当前工作目录，这是一个与 shell 会话状态紧密相关的操作。作为内部命令，它可以确保改变立即生效并影响后续命令的执行环境。</p><h3 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h3><blockquote><p>在你的 shell 中输入命令 ls.b | cat.b &gt; motd。</p><ul><li>请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？</li><li>请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul></blockquote><p>如下所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> ls.b | cat.b &gt; motd</span><br><span class="line">[00002803] pipecreate </span><br><span class="line">[00003805] destroying 00003805</span><br><span class="line">[00003805] free env 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00004006] destroying 00004006</span><br><span class="line">[00004006] free env 00004006</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free env 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free env 00002803</span><br><span class="line">i am killed ... </span><br></pre></td></tr></table></figure><p>一共有两次<code>spawn</code>，一次启动<code>ls.b</code>，另一次启动<code>cat.b</code></p><p>一共有四次进程销毁</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Lab6 的核心是实现 Shell 和管道通信。这个实验要求我们不仅要弄懂 Shell 是如何启动的，还要深入探究其工作原理，例如：它如何读取我们输入的命令，然后创建相应的进程来执行这些命令，以及如何管理进程之间的通信。<br>总而言之，Lab6 是一个综合性很强的顶层实验。在整个 MOS（操作系统）的开发过程中，我们采用的是一种自底向上的构建方法：从最底层的基本功能开始，然后添加系统调用，再到用户态的文件系统。现在，我们已经将整个系统推进到了用户层面，而 Lab6 正是这个用户层面的终极挑战，它需要我们灵活运用之前搭建的所有模块来共同完成。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>与之前的实验相比，Lab6 的设计更加友好，并且没有安排上机考试，给了我们更宽松的探索空间。</p><p>正如之前提到的，Lab6 作为整个 MOS 项目的收官之作，它的完成标志着我们这门操作系统课程的学习也圆满结束。用这样一个需要融会贯通所有知识点的综合性实验来为整个学期画上句号，我觉得是再好不过的安排了。它真正让我们将一学期所学的知识付诸实践，看到了理论走向应用的成果。</p><p>总的来说，这学期的操作系统实验让我收获满满，非常感谢课程团队的精心设计和辛勤付出！</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit4_单元总结</title>
      <link href="/2025/06/13/OO-Unit4%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
      <url>/2025/06/13/OO-Unit4%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第四单元总结"><a href="#「BUAA-OO」第四单元总结" class="headerlink" title="「BUAA OO」第四单元总结"></a>「BUAA OO」第四单元总结</h1><blockquote><p>本篇博客记录了笔者面向对象编程第四单元的学习过程与思考，以及对本课程四个单元学习的总结（源码与指导书可以参考<a href="https://github.com/Old-Joy/BUAA_OO_2025/tree/Unit4">Github</a>）</p></blockquote><h2 id="第十三次作业"><a href="#第十三次作业" class="headerlink" title="第十三次作业"></a>第十三次作业</h2><p>题目要求实现一个能实现用户请求的图书馆系统。本单元代码作业简单、架构清晰、迭代量少，笔者在三次作业中均没有发现什么值得注意的问题。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/OO-Unit4/ClassDiagram_thirteenth.png"></p><h2 id="第十四次作业"><a href="#第十四次作业" class="headerlink" title="第十四次作业"></a>第十四次作业</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/OO-Unit4/ClassDiagram_fourteenth.png"></p><h2 id="第十五次作业"><a href="#第十五次作业" class="headerlink" title="第十五次作业"></a>第十五次作业</h2><h3 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/OO-Unit4/ClassDiagram_fifteenth.png"></p><h2 id="正向建模与开发"><a href="#正向建模与开发" class="headerlink" title="正向建模与开发"></a>正向建模与开发</h2><p>正向建模与开发是一种**“从无到有”**的、系统化的产品创造过程。它从最初的需求和概念出发，通过系统性的设计、建模、仿真和验证，最终制造出符合预期的产品。</p><p>正向建模是正向开发流程中的核心环节之一，指的是在<strong>产品尚未实际存在之前</strong>，依据其功能需求、性能指标和设计规则，在数字世界中构建其虚拟模型的过程。这个模型是产品的“数字蓝图”。在本单元中，这个和我们先画类图再编写代码是相吻合的。</p><p>而正向开发则是一个更宏观的概念，它涵盖了从市场调研、概念提出、设计、建模、测试、生产到最终交付的全过程。正向建模是正向开发流程中的一个关键技术手段。</p><p>在本单元的练习中，我们主要用到了三种UML建模语言，分别是类图、状态图和顺序图</p><h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p>类图会描述系统的静态结构。它告诉你系统里有什么（类），它们各自的属性和行为是什么，以及它们之间有什么样的静态关系。它是UML中最核心、最基础的图之一，也是面向对象编程的直接体现。它展示了系统的静态蓝图。</p><p>在正向建模的初期，当我们通过需求分析知道了系统的需求之后，首先就要用类图来搭建系统的核心结构。在正向建模中，类图是第一个、也是最重要的产出物。</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>状态图，也叫状态机图，用来描述一个对象的生命周期。它告诉你一个对象从创建到销毁会经历哪些状态，以及是什么事件触发了状态的改变。状态图专注于描述单个对象在其生命周期中可能经历的各种状态，以及如何从一个状态转换到另一个状态。</p><p>当系统的静态骨架（类图）搭建好后，我们会发现有些对象（类）的行为非常复杂，它在不同时间会表现出完全不同的行为。这时就需要状态图。在正向建模中，状态图是对类图的深化和补充，确保项目能够在各种内外环境下安全、正确的运行。</p><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>顺序图，也叫时序图，用来描述对象之间的动态交互。它告诉你为了完成某个特定功能，不同对象之间是如何按时间顺序发送和接收消息的。顺序图是一种交互图。它通过描绘对象之间发送消息的时间顺序来显示多个对象之间的动态协作。</p><p>在正向建模中，顺序图是确保系统动态行为正确性的关键工具。它模拟了真实场景下各个部分是如何协作，以完成一个特定任务的。</p><h3 id="保证三种图的一致性"><a href="#保证三种图的一致性" class="headerlink" title="保证三种图的一致性"></a>保证三种图的一致性</h3><p>在正向建模和整个软件开发生命周期中，保持类图、状态图和顺序图之间的一致性至关重要。如果它们之间出现矛盾，整个设计模型就会失去意义，甚至会误导后续的开发工作。三种图从不同视角描述同一个系统，如果它们的信息不一致，说明设计本身存在逻辑矛盾和缺陷。</p><h2 id="大模型的辅助使用"><a href="#大模型的辅助使用" class="headerlink" title="大模型的辅助使用"></a>大模型的辅助使用</h2><p>大模型并非能够“自动”完成从建模到实现所有任务的黑盒。在建模、实现过程中，大模型应当更类似于“导航”系统的角色。要引导它在复杂场景中完成高质量的架构设计，关键在于<strong>设计师的主导作用</strong>和一套<strong>系统化的引导策略</strong>。</p><p>荣老师说，“要去拥抱新技术”。大模型的到来并不是一件灾难性的事情，但这也并不意味着我们可以完全依赖大模型。目前的大模型依然存在很多缺点，它拥有全面的资料，却不一定能够全部理解它们。笔者总结了一些大模型的引导方法：</p><ol><li>上下文精确注入：为模型设定“设计边界”<br> 大模型本身缺乏真实世界的项目背景。若是直接让其设计一个项目，其答案会因泛泛而谈而毫无价值。因此，第一步必须是为其构建一个精确的环境，比如赋予大模型一个身份，抑或是明确业务需求与约束、技术栈、设计模式等等。</li><li>任务分解与迭代式生成：将“大问题”拆解为“小步骤”<br> 面对复杂架构，不能指望一步到位，需要逐层下降，引导模型分层、分步地思考。这种分解式的引导，本质上是模拟了我们课程中所学的<strong>正向建模</strong>流程，确保了设计的系统性和逻辑性。</li><li>批判性思维与一致性校验：从“全盘接收”到“审慎质询”<br> 大模型最致命的弱点是“一本正经的胡说八道”。它缺乏对设计一致性的自我审查能力。程序员的批判性思维是不可或缺的一环。<br> 面对大模型给出的答案，我们多问“为什么”，多去和真实情景对比、质询，而不是一抄了事。定义问题、进行关键决策、保证设计完整性和一致性的核心职责，<strong>始终应当掌握在人类设计师手中</strong>。</li></ol><h2 id="总结四个单元"><a href="#总结四个单元" class="headerlink" title="总结四个单元"></a>总结四个单元</h2><h3 id="架构设计思维的演进"><a href="#架构设计思维的演进" class="headerlink" title="架构设计思维的演进"></a>架构设计思维的演进</h3><p>四个单元一路<del>肘</del>来，收获还是很不少的。第一单元吃了一个大亏，之后再也不敢在架构设计上怠慢了。自第一单元后，再也没出现过架构导致的 WRONG ANSWER 问题。</p><p>当时第一单元的第二次作业，对<strong>封装</strong>的理解尚且不彻底，在递推函数的解析上面吃了很大的亏。后来渐渐理解到封装的含义，把任务下放给每个类，宏观上只管调用并信任类给出的方法，这是第一单元的“递归下降”里最重要的知识。</p><p>自此以后，笔者也打消了“绝不重构”的念头，每次写作业，尽量做到架构上的清晰简洁、可维护性好、可扩展性好。在后几个单元里都做得比较理想。</p><p>架构设计是很重要的，一个好的架构能让任务的完成更清晰、思路明确，能让程序员更容易理解代码的逻辑。无论是维护、扩展、测试都会有一个好的导向。</p><h3 id="测试思维的演进"><a href="#测试思维的演进" class="headerlink" title="测试思维的演进"></a>测试思维的演进</h3><p>第一单元的时候还不会写评测机，当时也吃了不少亏。捏测试点的时候感觉很有自信，把好多情况都考虑了，其实想到的根本不全面。当时也只会黑盒测试。如果当时懂得代码走查的重要性的话，一定是能感觉到递推函数内部逻辑解析有情况遗漏的。</p><p>第二单元，一方面开始训练自己代码走查的能力，另一方面开始学会搭建评测机了。当时使用代码走查看出自己代码很多线程不安全的地方，在互测里也看到房友代码上的缺点，捏造测试点成功hack了，也是当时房间里唯一hack的人。另一方面，评测机搭建的强度也很高。关于数据生成，我才用了很多策略来提高数据点的强度，又设置了很多限制来保证数据点的正确性与有效性。最后就是正确性判定方面，我先是自己多思考、多判断，然后又根据大模型的辅助，提高正确性判定的严密性，最后也是在第二单元打出了很不错的成绩。</p><p>在这之后，对代码进行测试的时候就很灵活了。</p><h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p>OO 的路已经告一段落了。到了这个份上，好像说不出什么特别有大道理的话。硬要说，笔者的收获更多还不是知识层面的。</p><p>刚开始接触的时候还是比较忐忑的，第一单元，对面向对象的思路还不是特别清晰。刚开始拿到作业要求的时候还不知道要从哪方面下手，看了好多博客才渐渐的有了思路。当时确实不会设计架构，现在反过来看第一单元三次作业的代码都感觉是<del>屎山中的屎山</del>。</p><p>但随着慢慢的接触，设计架构越来越得心应手了。对往届学长学姐的博客参考也少了很多，逐渐学会了在拿到要求之后先自己思考、设计，最后完成比较全面的、优良的项目。</p><p>面向对象是个值得深入研究的课题。大一只学过C语言的面向过程，刚接触到面向对象的时候是比较诧异的，“哇，代码还能这么写”（上完OOpre和舍友聊天的原话）。比如，封装的意识是面向过程编程体会不到的，就好比面对一个机器，你让它干什么它就干什么，但你从外部是无法得知它是如何实现的，看不到内部的状态，这种感觉真的好生奇妙。这样既提高了安全性，也降低了复杂度。</p><p>OO 的过程中有过喜悦，有过难过。在 OO 的路上，结识了很多友好的同学和助教，也犯过错误，认识到不足并改正。OO 课程陪伴了我们一个学期，给我们带来了极多截然不同的体验，<del>想必我这辈子都忘不了你了</del>。</p><p>衷心祝愿 OO 课能够越办越好，也希望自己能够当选 OO 助教，再和 OO 一起走一年！</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OO_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab5_实验报告</title>
      <link href="/2025/05/30/OS-Lab5/BUAA-OS-Lab5%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/05/30/OS-Lab5/BUAA-OS-Lab5%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab5-实验报告"><a href="#BUAA-OS-Lab5-实验报告" class="headerlink" title="BUAA-OS-Lab5 实验报告"></a>BUAA-OS-Lab5 实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><blockquote><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p></blockquote><p>当外部设备产生中断信号或者更新数据时，此时Cache中之前旧的数据可能刚完成缓存，那么完成缓存的这一部分无法完成更新，则会发生错误的行为。<br>缓存机制的设计是为了提高效率，让数据发生改变的时候不立即写入内存，而是等Cache发生替换的时候才写进去。<br>而对于串口设备这种读写频繁、实时交互的设备来说，如果写入 kseg0 部分，数据可能很久都不被真正写入内存中，引发错误。在相同的时间内，发生读写错误的概率远高于IDE磁盘。</p><h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p></blockquote><ul><li>一个磁盘块的大小为<strong>4KB</strong>，一个文件控制块的大小为<strong>256B</strong>，一个磁盘块中最多有<strong>16个</strong>文件控制块。</li><li>一个目录大小为<strong>4KB</strong>，所以一个目录下<strong>最多有1024个</strong>目录项，也就是最多可以指向<strong>1024个</strong>磁盘块。每一个磁盘块有最多有<strong>16</strong>个文件控制块，所以一个目录最多有<strong>16K个</strong>文件。</li><li>一个文件有<strong>直接指针</strong>+<strong>间接指针</strong>共1024个。每个指针指向一个磁盘块，存储着该文件的一部分文件数据。所以文件系统支持的单个文件最大为<strong>4MB</strong></li></ul><h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure><p>由代码可知最大磁盘大小为1GB。</p><h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><blockquote><p>在本实验中， fs&#x2F;serv.h、 user&#x2F;include&#x2F;fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure><p><code>user/include/fs.h</code>里面，这两个宏分别用来找<code>fd</code>对应的<strong>文件信息页面</strong>和<strong>文件的缓存区地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BLOCK_SIZE / SECT_SIZE) <span class="comment">/* sectors to a block */</span></span></span><br></pre></td></tr></table></figure><p>可以实现 sect 号到 block 号的转换。</p><h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</p></blockquote><p>会共享</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/testfork&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>((r = fork()) == <span class="number">0</span>) &#123; <span class="comment">//子进程</span></span><br><span class="line">    n = read(fd, buf, <span class="number">3</span>);</span><br><span class="line">    debugf(<span class="string">&quot;child : %s\n&quot;</span>, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程</span></span><br><span class="line">    n = read(fd, buf, <span class="number">3</span>);</span><br><span class="line">    debugf(<span class="string">&quot;father : %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件<code>/testfork</code>种的内容为<code>abcdef</code></p><p>而输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child : abc</span><br><span class="line">father : def</span><br></pre></td></tr></table></figure><p>所以文件指针和文件描述符是会共享的</p><h3 id="Thinking-5-5-1"><a href="#Thinking-5-5-1" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File结构体表示一个文件或目录的元数据，既存在于磁盘上的物理结构，也存在于文件系统服务进程的内存中。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名或目录名</span></span><br><span class="line">    <span class="type">uint32_t</span> f_size;         <span class="comment">// 文件或目录占据的存储空间大小，以字节为单位</span></span><br><span class="line">    <span class="type">uint32_t</span> f_type;         <span class="comment">// 文件的类型标识，区分文件和目录</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// 直接指针数组，指向包含文件内容的磁盘块地址</span></span><br><span class="line">    <span class="type">uint32_t</span> f_indirect;     <span class="comment">// 间接指针，指向一个磁盘块，该磁盘块存储了指向文件内容的其他磁盘块地址</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>      <span class="comment">// 指向该文件所属目录的指针，此字段仅在内存中表示有效</span></span><br><span class="line">    <span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)]; <span class="comment">// 用于字节对齐的填充字段，确保结构体大小为256字节</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fd结构体代表一个文件描述符，它存储在内存中，包含了关于文件操作的上下文信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    u_int fd_dev_id; <span class="comment">// 设备标识符，用于识别文件所属的外设类型</span></span><br><span class="line">    u_int fd_offset; <span class="comment">// 文件偏移量，表示当前文件操作的读写位置</span></span><br><span class="line">    u_int fd_omode;  <span class="comment">// 文件打开模式，指定了文件的操作权限，如读写、只读、只写等</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filefd结构体结合了文件描述符和文件元数据，提供了对文件操作的完整上下文。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span>       <span class="comment">// 文件描述符，包含设备ID、偏移量和打开模式</span></span><br><span class="line">    u_int f_fileid;       <span class="comment">// 文件标识符，用于唯一标识一个文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span>   <span class="comment">// 文件元数据，包含了文件名、大小、类型等属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><blockquote><p>下图（文件系统服务时序图）中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><p>在图5.7中，我们可以观察到两种不同类型的箭头，分别是实心箭头和虚线箭头。实心箭头用于表示同步消息，而虚线箭头则表示返回消息。</p><p>init 进程创建了<code>fs</code>和<code>user</code>两个进程。用户进程和文件系统之间的箭头表明二者之间存在交互，用户进程发出需求，文件系统实现。</p><p>通信的基本流程如下：首先，用户空间调用<code>user/lib/file.c</code>中提供的文件操作函数，如<code>open</code>。这些函数随后调用<code>user/lib/fsipc.c</code>的函数。传递所需的操作类型码，并进行<code>ipc_send</code>，向文件系统发送请求，并用<code>ipc_rcv</code>来接收结果。</p><p>文件系统接收到请求后，使用<code>serv.c</code>中的函数来处理请求。处理结束后，再次调用<code>ipc_send</code>把结果传给用户进程，用户进程继续运行。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><p>本次实验中需要填补的内容并不是很多，难度并不算大，但是MOS的文件系统本身比较复杂，里面错综复杂的调用关系需要理清楚才行。文件系统中有很多非常长的文件，这些文件本身内部的函数比较多比较复杂，需要对里面的内容进行一个比较清楚的把握。</p><p>这些函数调用其实都是实现文件系统的一系列操作，本质上都是一样的，只不过调用是一层一层向里面调用的。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab5的上机倒是挺煎熬的。exam因为理解的不够到位，导致卡了好久，最后在助教的帮助下才过了，extra简单的看了看，很复杂，不过有一个整体的思路，里面还有很多很多细节。</p><p>OS的上机到这就结束了。这种上机节奏感觉还是很不错的，课下的任务给足了提示和解释，简单浏览代码就可以完成；上机要求对代码的整体架构有一个清晰的把握，需要稍微深入地阅读有关的代码。这种方式其实挺好，确保了我们每周都会花一定的时间来浏览整个代码，所以最后对MOS的内部逻辑还是了解的挺好的。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit3_单元总结</title>
      <link href="/2025/05/18/OO-Unit3%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
      <url>/2025/05/18/OO-Unit3%E6%80%BB%E7%BB%93/%E3%80%8CBUAA%20OO%E3%80%8D%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第三单元总结"><a href="#「BUAA-OO」第三单元总结" class="headerlink" title="「BUAA OO」第三单元总结"></a>「BUAA OO」第三单元总结</h1><h2 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h2><p>本次面向对象编程第三单元的主题是：「BUAA OO」第三单元总结</p><ul><li>第九次作业：根据 JML 规格实现<code>Person</code>类、<code>Tag</code>类、<code>Network</code>类</li><li>第十次作业：根据 JML 规格实现<code>OfficialAccount</code>类</li><li>第十一次作业：根据 JML 规格实现<code>Message</code>类及其3个子类</li></ul><h2 id="三次迭代说明"><a href="#三次迭代说明" class="headerlink" title="三次迭代说明"></a>三次迭代说明</h2><h3 id="第九次作业"><a href="#第九次作业" class="headerlink" title="第九次作业"></a>第九次作业</h3><p>本次作业主要是根据JML规格实现三个接口中的所有方法，按照JML规格严格实现理论上就是正确的，所以其实要多注意细节；但是完全按照JML实现显然是不行的，<del>哈哈tle了吧</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ ensures \result ==</span></span><br><span class="line"><span class="comment">      @         (\sum int i; 0 &lt;= i &amp;&amp; i &lt; persons.length;</span></span><br><span class="line"><span class="comment">      @             (\sum int j; i &lt; j &amp;&amp; j &lt; persons.length;</span></span><br><span class="line"><span class="comment">      @                 (\sum int k; j &lt; k &amp;&amp; k &lt; persons.length</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[i].getId()).isLinked(getPerson(persons[j].getId()))</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[j].getId()).isLinked(getPerson(persons[k].getId()))</span></span><br><span class="line"><span class="comment">      @                     &amp;&amp; getPerson(persons[k].getId()).isLinked(getPerson(persons[i].getId()));</span></span><br><span class="line"><span class="comment">      @                     1)));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryTripleSum</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>比较典型的就是这个，按照JML里面写三重循环显然是会寄的，所以要想别的方法。</p><p><del>经过和ai的讨论</del>，笔者发现其实可以用动态维护的方法。也就是说，先把这个值初始化成0，然后每次<code>addRelation</code>或者<code>modifyRelation</code>或者等等时，按照要求更新值的大小。这样其实是把算法的压力分配到了加减关系上面了，而且这样做耗时短，同时也避免了冗余的计算，<del>比如哪个坏蛋给你卡好几次<code>qts</code>这你不炸了吗</del>。</p><p>除此之外，别的优化笔者倒是没怎么做。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_ninth.png" alt="第9次作业类图"></p><p>整体架构图如上所示，除了题目要求的类笔者并没有新增别的类。</p><h4 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_ninth.png" alt="第9次作业代码复杂度"></p><p>这次作业的整体复杂度不算特别高。比较高的<code>Network</code>类里面是在维护查询的数据。</p><h4 id="Junit测试感悟"><a href="#Junit测试感悟" class="headerlink" title="Junit测试感悟"></a>Junit测试感悟</h4><p>Junit的测试一开始有一个点一直卡着过不去，经过仔细阅读指导书后发现是<code>pure</code>测试的关键。一个方法是<code>pure</code>的，关键就在于在它调用前后，对象的属性不应当发生改变。所以，测试<code>pure</code>的关键就在于在调用该方法之前，将其要操作的对象深拷贝，然后和它调用后的对象进行比较。<del>当然有个更直白的方法就是直接新建两个属性一样的实例，其中某个作为对照组来测试，管它什么拷贝</del></p><h3 id="第十次作业"><a href="#第十次作业" class="headerlink" title="第十次作业"></a>第十次作业</h3><p>本次作业新增了一个<code>OfficialAccount</code>类，另外，原先的类里面也有一些新的迭代内容。</p><p>本次强测tle了好几个点，<del>五一玩的太嗨了</del>，没有做细致的优化。比较卡时间的就是这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(personId) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          getPerson(personId).containsTag(tagId);</span></span><br><span class="line"><span class="comment">      @ ensures \result == getPerson(personId).getTag(tagId).getValueSum();</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) !containsPerson(personId);</span></span><br><span class="line"><span class="comment">      @ signals (TagIdNotFoundException e) containsPerson(personId) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                    !getPerson(personId).containsTag(tagId);</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryTagValueSum</span><span class="params">(<span class="type">int</span> personId, <span class="type">int</span> tagId)</span> <span class="keyword">throws</span> PersonIdNotFoundException, TagIdNotFoundException;</span><br></pre></td></tr></table></figure><p>这个其实跟前一次作业还是一样的，做好动态规划就好了，并不是什么复杂的问题。当然这个要做动态规划的话还要注意一些深层次的细节。笔者在完成了动态规划之后还有一些细节上的bug，处理了很久。在第十一次作业的自测过程中，与这个方法有关还出了一个非常细小的bug，这个之后再说。</p><p>在互测过程中，笔者也针对性的设计了一些和<code>qtvs</code>有关的测试数据，成功hack到了房友。</p><p>另外，在进行了上述优化之后，所有强测点，笔者最慢的在本地用profiler分析，也能压缩到1600ms以内，但是评测机跑下来就是tle，<del>真该加强一下这个烂评测机了</del>。所以笔者在仔细考虑之后，将这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(id1) &amp;&amp; id1 == id2 ;</span></span><br><span class="line"><span class="comment">      @ ensures \result==0 ;</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public normal_behavior</span></span><br><span class="line"><span class="comment">      @ requires containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          containsPerson(id2) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          id1 != id2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\exists PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @          path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[path.length - 1].equals(getPerson(id2));</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i])));</span></span><br><span class="line"><span class="comment">      @ ensures  (\exists PersonInterface[] pathM;</span></span><br><span class="line"><span class="comment">      @          pathM.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          pathM[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          pathM[pathM.length - 1].equals(getPerson(id2)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; pathM.length; pathM[i - 1].isLinked(pathM[i]));</span></span><br><span class="line"><span class="comment">      @          (\forall PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @          path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          path[path.length - 1].equals(getPerson(id2)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i]));</span></span><br><span class="line"><span class="comment">      @          (\sum int i; 0 &lt;= i &amp;&amp; i &lt; path.length; 1) &gt;=</span></span><br><span class="line"><span class="comment">      @          (\sum int i; 0 &lt;= i &amp;&amp; i &lt; pathM.length; 1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @          \result==(\sum int i; 1 &lt;= i &amp;&amp; i &lt; pathM.length; 1));</span></span><br><span class="line"><span class="comment">      @ also</span></span><br><span class="line"><span class="comment">      @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) !containsPerson(id1);</span></span><br><span class="line"><span class="comment">      @ signals (PersonIdNotFoundException e) containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                       !containsPerson(id2);</span></span><br><span class="line"><span class="comment">      @ signals (PathNotFoundException e) containsPerson(id1) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @                                   containsPerson(id2) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         !(\exists PersonInterface[] path;</span></span><br><span class="line"><span class="comment">      @         path.length &gt;= 2 &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         path[0].equals(getPerson(id1)) &amp;&amp;</span></span><br><span class="line"><span class="comment">      @         path[path.length - 1].equals(getPerson(id2));</span></span><br><span class="line"><span class="comment">      @         (\forall int i; 1 &lt;= i &amp;&amp; i &lt; path.length; path[i - 1].isLinked(path[i])));</span></span><br><span class="line"><span class="comment">      @*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*@ pure @*/</span> <span class="type">int</span> <span class="title function_">queryShortestPath</span><span class="params">(<span class="type">int</span> id1,<span class="type">int</span> id2)</span> <span class="keyword">throws</span> PersonIdNotFoundException, PathNotFoundException;</span><br></pre></td></tr></table></figure><p>由常规的BFS算法，即广度优先算法，优化成了双向BFS算法。至此之后，最慢的点也能在500ms就能跑完了。</p><p>双向 bfs，或说图的双向搜索算法，是对于广度优先搜索算法的一种改进。bfs 从起点开始由浅入深地遍历，直到找到终点；而双向 bfs 则从起点与终点同时开始遍历，直到遍历的区域相交（说明找到了最短路径）。</p><h4 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_tenth.png" alt="第10次作业类图"></p><h4 id="代码复杂度分析-1"><a href="#代码复杂度分析-1" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_tenth.png" alt="第10次作业代码复杂度"></p><p>本次作业复杂度整体就有点高了，主要集中在<code>Network</code>类，因为其中包含了<code>queryShortestPath</code>方法和<code>modifyRelation</code>方法。</p><h3 id="第十一次作业"><a href="#第十一次作业" class="headerlink" title="第十一次作业"></a>第十一次作业</h3><p>这次作业主要新增了<code>Message</code>类以及它的三个子类。</p><p>本次作业值得注意的点倒是不算多，笔者个人认为只有一个：在第十一次作业里面，<code>sendMessage</code>的加入，可能使得相同的文章可能会被转发到一个人的容器中。在删除的时候，需要将所有该id的文章都删掉。</p><p>另外，在自行测试的时候，笔者发现了一个非常隐蔽的bug。因为<code>Tag</code>是允许id相同但是实例不同的。也就是说，两个<code>person</code>，他们各自拥有一个<code>tag</code>，这两个<code>tag</code>显然实例是不同的，但是他们可以拥有相同的id。在笔者的实现中，当发生了<code>modifyRelation</code>的时候，需要找到同时包含这两个<code>person</code>的<code>tag</code>，因此笔者采用了一个<code>HashMap</code>来记录这个人所在的<code>tag</code>，而key便是使用了<code>tag</code>的id。然而，一个人可能同时处于id相同的不同<code>tag</code>里面，<code>HashMap</code>的key一定是唯一的，所以用<code>HashMap</code>来记录必然是错误的。</p><p>笔者在与小伙伴们讨论之后，采用了这样一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TagKey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ownerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> tagId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TagKey</span><span class="params">(<span class="type">int</span> ownerId, <span class="type">int</span> tagId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ownerId = ownerId;</span><br><span class="line">        <span class="built_in">this</span>.tagId = tagId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="type">TagKey</span> <span class="variable">tagKey</span> <span class="operator">=</span> (TagKey) o;</span><br><span class="line">        <span class="keyword">return</span> ownerId == tagKey.ownerId &amp;&amp; tagId == tagKey.tagId; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(ownerId, tagId); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这样的一种数据结构来记录<code>tag</code>的“唯一id”，这样就确保了key是唯一的</p><h4 id="架构图-2"><a href="#架构图-2" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/img/OO-Unit3/ClassDiagram_eleventh.png" alt="第11次作业类图"></p><h4 id="代码复杂度分析-2"><a href="#代码复杂度分析-2" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p><img src="/img/OO-Unit3/Magnanimity_eleventh.png" alt="第11次代码复杂度"></p><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="测试思想"><a href="#测试思想" class="headerlink" title="测试思想"></a>测试思想</h3><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><blockquote><p>黑盒测试，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。<br>——百度百科，黑盒测试</p></blockquote><p>评测机其实就是一种黑盒测试，它只关心程序是否能产生正确的输出，不关心程序内部是如何运作的。</p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><blockquote><p>白盒测试是一种测试用例设计方法，盒子指的是被测试的软件，白盒指的是盒子是可视的，即清楚盒子内部的东西以及里面是如何运作的。“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。<br>——百度百科，白盒测试</p></blockquote><p>本单元要求学生设计的 Junit 测试便是一种白盒测试，它要求被测方法的行为完全符合规格说明，不能产生越界的行为。</p><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试是针对程序模块来进行正确性检验的测试工作。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法。单元测试的目标是隔离程序部件并证明这些单个部件是正确的。</p><p>本单元的Junit就是一种单元测试。</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><blockquote><p>功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。功能测试也叫数据驱动测试，只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码。<br>——百度百科，功能测试</p></blockquote><p>功能测试其实就是一种黑盒测试。</p><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><blockquote><p>集成测试，即对程序模块采用一次性或增值方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。该测试，可以由程序员或是软件品保工程师进行。<br>——Wikipedia，集成测试</p></blockquote><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>压力测试，顾名思义就是针对特定的系统、组件、程序等，采用超过正常使用条件下的情况进行运转，确认在极限状态下，程序是否能够正常运转。</p><p>到目前笔者还没用使用过这种测试方式，但似乎航空航天设计经常会使用这种测试方法（确认系统在什么条件下会损坏，以及安全使用条件）。</p><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><blockquote><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。<br>——百度百科，回归测试</p></blockquote><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><p>本次笔者只写了一个简易的数据生成器，规范了生成数据的合法性以后，手动添加了一些条件来增加数据的强度。生成数据时应当优先考虑JML规格中描述的每一个方法的behavior。由于时间有限，并没有刻意去构造足够强大的测试数据。因此笔者的数据生成器主要在本地测试时发挥了作用，在互测阶段成功刀中了几个人。</p><h2 id="如何引导大模型在不同场景下完成复杂任务"><a href="#如何引导大模型在不同场景下完成复杂任务" class="headerlink" title="如何引导大模型在不同场景下完成复杂任务"></a>如何引导大模型在不同场景下完成复杂任务</h2><p>现在的大模型整体可用性非常高，一般来讲不用刻意去多步引导。笔者尝试过直接使用大模型完成第十一次作业，其完成的比较完善，性能方面有所欠缺，<del>代码风格惨不忍睹</del>，但其他方面确实很优异，笔者只进行了细节上的优化与维护和性能上的改善。</p><h2 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h2><p>契约式设计是一种设计计算机软件的方法。这种方法要求软件设计者为软件组件定义正式的，精确的并且可验证的接口。</p><p>契约式设计的核心在于分离规格设计与代码实现。设计者通过需求来设计与撰写每个方法的规格，程序员通过规格来实现代码。这种设计思想可以有效减少代码中的bug数量，提高代码的可靠性与可维护性；但由于契约式设计需要为每个类书写详细的契约（契约长度往往会超过代码本身的长度），这种设计方式会显著地降低开发的速度。因此在实际应用中往往在设计代码的核心模块中使用，以保证核心模块的正确性。</p><p>JML是一门非常冷门的规格建模语言，课程组并未让学生们完成由需求设计规格这一层次，而是将三次迭代的重点放在了由规格实现代码。基于规格的层次化设计有两个层次，一是根据需求设计规格，二是根据规格实现代码。课程组将绝大部分重心都放到了后者之上，笔者认为不是很合理。可以尝试让同学们自己编写JML规格。</p><h2 id="Junit测试"><a href="#Junit测试" class="headerlink" title="Junit测试"></a>Junit测试</h2><p>Junit测试是由规格设计引来的测试，旨在验证代码是否符合规格说明书。想要进行Junit测试，前提是拥有一个完全正确的规格，否则Junit测试完全是一纸空谈。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>本次Junit测试我并没有考虑随机数据构造，只是选择了15-30个有特色的数据点进行测试充分覆盖JML规格中各个<code>behavior</code>的<code>requires</code>和<code>ensures</code>。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>深度检査JML规格中<code>not_assigned</code>的属性，保存一份方法执行前的深拷贝，保证各个属性未发生变化。逐行检查<code>requires</code>和<code>ensures</code>。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本单元的学习，笔者大致学习到规格化设计的步骤，体会到规格化设计的优点。本单元对于Junit的学习，让我理解了Junit的使用方法与其存在的意义。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OO_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab4_实验报告</title>
      <link href="/2025/05/09/OS-Lab4/BUAA_OS_Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/05/09/OS-Lab4/BUAA_OS_Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab4-实验报告"><a href="#BUAA-OS-Lab4-实验报告" class="headerlink" title="BUAA_OS_Lab4_实验报告"></a>BUAA_OS_Lab4_实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><blockquote><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 <code>msyscall</code>留下的信息吗？</li><li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 <code>msyscall</code> 时同样的参数的？</li><li>内核处理系统调用的过程对 <code>Trapframe</code> 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul></blockquote><ul><li>内核在保护现场的时候会调用<code>SAVE_ALL</code>宏，把通用寄存器的<code>sp</code>复制到<code>$k0</code>中。保存现场需要使用<code>$v0</code>作为协寄存器到内存的中转寄存器，写到内存时需要<code>sp</code>，所以在正式保存协寄存器和通用寄存器前先保存这两个寄存器。</li><li>可以的。因为内核在陷入内核、保存现场的过程中，寄存器 a0-a3 中的值都没有被破坏。用户在调用 msyscall 时，传入的参数会被保存在 a0-a3 寄存器和堆栈中。当陷入内核时，a0-a3 寄存器不会被破坏，并且会将用户栈中的相应参数复制取出到内核栈中。因此，<code>sys_*</code> 函数可以从寄存器和用户栈处获得用户调用 msyscall 时传入的参数值。</li><li>更改了 epc 的值（+4），使得返回用户态后能够正常执行下一条指令；返回值会被存储到 v0 寄存器内，使得返回用户态后可以获取调用后的返回值。</li></ul><h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><blockquote><p>思考 <code>envid2env</code> 函数: 为什么 <code>envid2env</code> 中需要判断 <code>e-&gt;env_id != envid</code> 的情况？如果没有这步判断会发生什么情况？</p></blockquote><p>我们在试图通过 <code>envid</code> 来获取对应的进程控制块时，只取了 <code>envid</code> 的后 10 位来作为数组下标。但要确保 <code>envid</code> 和取出的进程块<strong>完全对应</strong>，所以我们仅仅看后 10 位是不够的。用 <code>e-&gt;env_id != envid</code> 这一步来确定传入的 <code>envid</code> 确实和取出的进程块是对应的。如果不判断envid是否相同，会取到错误的或者本该被销毁的进程控制块。</p><h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><blockquote><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 <em>kern&#x2F;env.c</em> 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 <code>0</code>，请结合系统调用和 <em>IPC</em> 部分的实现与<code>envid2env()</code> 函数的行为进行解释。</p></blockquote><p>在系统调用和 ipc 通讯的相关函数里，我们如果传入的 <code>envid</code> 为 0，那么代表相应的进程为 <strong>当前进程</strong>。因此，需要保证每一个进程块的 <code>envid</code> 不为 0，才能让这个标准正确实现。</p><h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><blockquote><p>关于 <code>fork</code> 函数的两个返回值，下面说法正确的是：<br>A、 <code>fork</code> 在父进程中被调用两次，产生两个返回值<br>B、 <code>fork</code> 在两个进程中分别被调用一次，产生两个不同的返回值<br>C、 <code>fork</code> 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>D、 <code>fork</code> 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p></blockquote><p>C</p><h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><blockquote><p>我们并不应该对所有的用户空间页都使用 <code>duppage</code> 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 <em>kern&#x2F;env.c</em> 中 <code>env_init</code> 函数进行的页面映射、 <em>include&#x2F;mmu.h</em> 里的内存布局图以及本章的后续描述进行思考。</p></blockquote><ul><li>在 0 - <code>USTACKTOP</code> 范围的内存需要使用 <code>duppage</code> 进行映射;</li><li><code>USTACKTOP</code> 到 <code>UTOP</code> 之间的 <strong>user exception stack</strong> 是用来进行页写入异常的，不会在处理COW异常时调用 <code>fork()</code> ,所以 <code>user exception stack</code> 这一页不需要共享；</li><li><code>UTOP</code>以上页面的<strong>内存与页表</strong>是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的<code>duppage</code>；</li><li>其上范围的内存要么<strong>属于内核</strong>，要么是所有用户进程<strong>共享的空间</strong>，用户模式下只可以读取。除只读、共享的页面外都需要设置 <code>PTE_COW</code> 进行保护。</li></ul><h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><blockquote><p>在遍历地址空间存取页表项时你需要使用到 <code>vpd</code> 和 <code>vpt</code> 这两个指针，请参考 <em>user&#x2F;include&#x2F;lib.h</em> 中的相关定义，思考并回答这几个问题：</p><ul><li>vpt 和 vpd 的作用是什么？怎样使用它们？</li><li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种方式来修改自己的页表项吗？</li></ul></blockquote><ol><li><code>vpt</code> 和 <code>vpd</code> 分别是指向用户页表和用户页目录的指针。它们用于访问和遍历进程的地址空间中的页表项。以 <code>vpt</code> 为例，要获取当前虚拟地址 <code>va</code> 所对应的页表项，可以使用 <code>vpt[VPN(va)]</code>，使用宏 <code>VPN(va)</code> 获取虚拟地址 <code>va</code> 对应的页面的编号，即相对 <code>(*vpt)</code> 的偏移量，通过这个偏移量就可以得到对应的页表项。</li><li>存储页表的空间属于用户空间，因此用户进程可以通过指针取得页表的地址来进行访问。系统是线性地进行页面的映射，因此可以很方便地实现“虚拟地址-&gt;虚拟页号”的转变。虚拟页号即虚拟地址对应的虚拟页面相对页表项的偏移量，获得了页表首地址和偏移量后，就可以获取对应的页表项。</li><li><code>vpd</code> 的值为 <code>(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT))</code>，在<code>UVPT</code>和<code>UVPT + PDMAP</code>之间，说明将页目录映射到了某一页表位置；通过 <code>vpt</code> 来找 <code>vpd</code>，这表明页表 <code>vpt</code> 中存在某一页为页目录，由此体现了自映射设计。</li><li>不能，该区域对用户<strong>只读不写</strong>，用户进程只能读取页表项，不能进行修改。想要修改需要陷入内核</li></ol><h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><blockquote><p>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 <code>Trapframe</code>运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</li><li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></blockquote><p>出现 COW 异常时，也即进程尝试写 COW 页面时，会出现这样的异常重入。</p><p>异常处理完毕之后，恢复现场的工作会在用户态进行，因此需要把 tf 保存在用户态的栈空间下。</p><h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><blockquote><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？</p></blockquote><ul><li>解放内核，不用内核执行大量的页面拷贝工作；</li><li>可以减少内核态和用户态之间的切换次数，从而提高异常处理的效率；</li><li>内核态处理失误产生的影响较大，可能会使得操作系统崩溃；</li><li>用户状态下不能得到一些在内核状态才有的权限，避免改变不必要的内存空间。</li></ul><h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><blockquote><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul></blockquote><p>确保在子进程创建过程中，页表项的修改能够被正确地加载到 TLB 中。如果不这样做，可能会导致在子进程创建过程中需要访问的页表项尚未被加载到 TLB 中，从而影响子进程的正常创建和运行。</p><h2 id="实验难点分析"><a href="#实验难点分析" class="headerlink" title="实验难点分析"></a>实验难点分析</h2><p>lab4 的主要内容主要包括系统调用、进程通信机制（ipc）以及 fork 操作。我觉得实验的难点在于对系统调用流程的理解和实现。在做实验的时候很容易忘记自己是基于内核还是基于用户。</p><p>而<code>fork</code>操作的难点在于理解子进程如何继承父进程的上下文，即，什么样的页面需要被赋予 COW 属性。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab4的上机还是比较轻松的。exam大概用了20分钟就写完了，主要就是要理解用户态和内核态函数调用的层次逻辑。extra有点难度，最后只拿了50分。整体感觉下来还是对C语言不够熟悉，有很多代码逻辑不是很清晰。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab3_实验报告</title>
      <link href="/2025/04/25/OS-Lab3/BUAA-OS-Lab3%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/04/25/OS-Lab3/BUAA-OS-Lab3%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BUAA-OS-Lab3-实验报告"><a href="#BUAA-OS-Lab3-实验报告" class="headerlink" title="BUAA_OS_Lab3_实验报告"></a>BUAA_OS_Lab3_实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><blockquote><p>请结合 MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code> 的含义。</p></blockquote><ul><li><code>e-&gt;env_pgdir</code> 代表当前进程的页目录的基地址。在 MOS 中，每个进程都有自己的页目录，用于存储该进程的页表信息。</li><li><code>PADDR(e-&gt;env_pgdir)</code> 代表这个函数获取页目录的物理地址。<code>PADDR</code>是一个宏，用于将内核虚拟地址转换为物理地址。</li><li><code>PTE_V</code> ：这是一个标志位，表示页表项有效。<code>PADDR(e-&gt;env_pgdir) | PTE_V</code>，表示给页目录的物理基地址加上权限位。</li><li><code>PDX(UVPT)</code>：这是一个宏，用于获取虚拟地址 <code>UVPT</code> 的页目录索引。</li></ul><p>所以，这行代码的作用是将当前进程的页目录的物理地址映射到用户虚拟地址空间的<code>UVPT</code>地址处，并设置页表项为有效。这样，进程就可以在自己的地址空间中访问页表和页目录，提高了访问效率。</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><blockquote><p><code>elf_load_seg</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。 请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote><p>在 <code>elf_load_seg</code> 函数中，<code>data</code> 参数是一个指向用户自定义数据的指针，它将被传递给 <code>map_page</code> 回调函数。</p><p>在 <code>load_icode</code> 函数中，当调用 <code>elf_load_seg</code> 时，<code>data</code> 参数被设置为当前环境结构 <code>struct Env *e</code> 的地址。这样，在 <code>map_page</code> 回调函数中，可以通过 <code>data</code> 参数访问到当前环境的信息，例如页目录 <code>env_pgdir</code> 和地址空间标识符 <code>env_asid</code>，这些信息对于将页面插入到正确的进程地址空间至关重要。</p><p>因此，<code>data</code> 参数是必需的，它使得 <code>elf_load_seg</code> 和 <code>map_page</code> 函数能够与调用者之间传递必要的数据。</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><blockquote><p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote><ul><li>处理程序段的虚拟地址 <code>p_vaddr</code> 没有对齐到页边界的情况，计算偏移量并实现对齐。</li><li>在任何调用 <code>map_page</code> 的地方，如果 <code>map_page</code> 返回非零值，表示映射失败，<code>elf_load_seg</code> 函数都会立即返回这个错误值。</li><li>如果段的内存大小 <code>p_memsz</code> 大于文件的尺寸 <code>p_filesz</code>，说明段在内存中比在文件中占据更多的空间。在这种情况下，需要额外分配页来填充这部分空间。</li></ul><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><blockquote><p>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：</p><ul><li>你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</li></ul></blockquote><p>虚拟地址。<code>CP0</code>中存储的<code>EPC</code>是CPU产生异常的指令地址，对于CPU来说，其所见的都是虚拟地址。</p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><blockquote><p>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用）涉及的 <code>do_syscall()</code> 函数将在 Lab4 中实现。</p></blockquote><p><code>genex.S</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM7</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">timer_irq:</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill</span><br><span class="line"></span><br><span class="line">#if !defined(LAB) || LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><blockquote><p>阅读 <code>entry.S</code>、<code>genex.S</code> 和 <code>env_asm.S</code> 这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p></blockquote><ol><li>异常处理。当发生异常的时候，会通过<code>mfc0 t0, CP0_STATUS</code>和<code>mtc0 t0, CP0_STATUS</code>指令来修改<code>CP0_STATUS</code>来关闭中断</li><li>系统调用</li><li>当异常处理或系统调用完成后，会通过 <code>ret_from_exception</code> 标签返回。在这里，会执行 <code>RESTORE_ALL</code> 和 <code>eret</code> 指令来恢复寄存器状态并返回到发生异常前的状态。</li><li>进程切换。</li></ol><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><ol><li>通过时钟中断来触发异常</li><li>异常处理程序先确定是时钟中断，并调用调度函数</li><li>调度函数通过一定的调度算法，选择一个新的进程开始执行</li><li>操作系统执行上下文的切换，保存当前进程、恢复新进程的状态</li><li>返回，执行新进程</li></ol><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次的课下lab虽然内容有点多但是整体难度其实不高，<del>毕竟跟着注释写就完事了</del>，但是比较难的是我们要对新增的文件以及我们在这个lab干了什么做一个比较完整的把握。</p><p>相比较之前的lab，这次的lab比较注重和理论课的联系，把理论课上进程调度仔细学好，才能好好参加本次的exam。建议一定要通读新增文件的每个函数的<code>Overview</code>，无论是否要求自己补全的</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次课下lab花费的时间不多，代码填空也没有很复杂的函数调用，所以仅仅完成课下任务是不行的，远不足以支撑我们完成限时测试。</p><p>另外，本次上机出现了一个令人难绷的bug，好在20:55的时候非常极限的找到并提交了，不得不说抗压能力是很重要的~</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit2_单元总结</title>
      <link href="/2025/04/20/OO-Unit2%E6%80%BB%E7%BB%93/OO-Unit2%20%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/"/>
      <url>/2025/04/20/OO-Unit2%E6%80%BB%E7%BB%93/OO-Unit2%20%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第二单元总结"><a href="#「BUAA-OO」第二单元总结" class="headerlink" title="「BUAA OO」第二单元总结"></a>「BUAA OO」第二单元总结</h1><h2 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h2><h3 id="写在动手之前"><a href="#写在动手之前" class="headerlink" title="写在动手之前"></a>写在动手之前</h3><p>在开始本次作业之前，需要明确几个问题：</p><p><strong>1.需要哪些线程</strong></p><p>首先自然是6个电梯6个线程，然后便是输入线程</p><p><strong>2.有哪些共享对象</strong></p><p>因为乘客都已经分配给某个电梯了，乘客自然就不能算共享对象，因为乘客只独属于某个电梯（线程）。那么还有什么算共享对象呢，笔者觉得应该是任务列表类。输入线程把读到的请求写到任务列表里面，6个电梯线程对任务列表进行读操作，获取属于各自的请求，完成请求后写回任务列表。</p><p>综上所述，整体框架就已经很明确了，在<code>MainClass</code>类里面，需要把6个电梯线程<code>Elevator</code>依次启动，再把输入线程<code>InputThread</code>启动，每个电梯线程有一个自己的任务列表<code>QuestList</code>，然后<code>InputThread</code>就根据请求的要求（电梯id）来把请求放到人物列表中，由电梯去完成</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_fifth.png" alt="第一次作业类图-电梯系统类图"></p><p>第一次作业类图如图所示，整体按照<em>生产者-消费者模型</em>去搭建的，美中不足的一点是笔者没有写分配器类，这样这个作业的可迭代性就不好</p><h3 id="同步块设计与锁"><a href="#同步块设计与锁" class="headerlink" title="同步块设计与锁"></a>同步块设计与锁</h3><p>第一次作业笔者只是用了<code>synchronized</code>关键字，并没有使用其他的锁。</p><p><img src="/img/OO-Unit2/synchronized.png" alt="第一次作业synchronized方法"></p><p>如图所示，笔者只在<code>QuestTable</code>里面用了<code>synchronized</code>方法，使得<code>InputThread</code>和<code>Elevator</code>线程对其操作是线程安全的。java目前的实现中<code>synchronized</code>的效率也是很高的，所以这种方法很清晰。不过荣老师上课讲过，最好应该是使用<code>synchronzied</code>代码块来上锁，这样更清晰，可拓展性也好，<strong>不要在方法上上锁</strong>。</p><h3 id="电梯调度"><a href="#电梯调度" class="headerlink" title="电梯调度"></a>电梯调度</h3><p>本次作业笔者主要采用了LOOK策略，逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">/*电梯内有人要出电梯或者电梯外有人要进电梯*/</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Operation.OPEN; <span class="comment">// 电梯开门</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*电梯内有人*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Operation.CONTINUE; <span class="comment">// 电梯按当前方向继续运行</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 电梯内没人</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/*所有电梯的任务表都为空*/</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="comment">/*所有请求都已完成*/</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.END; <span class="comment">// 电梯终止运行</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.WAIT; <span class="comment">// 电梯等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="comment">/*当前方向上还存在请求*/</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.CONTINUE; <span class="comment">// 电梯按当前方向继续运行</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Operation.REVERSE; <span class="comment">// 电梯掉头</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>Opreation</code>是一个枚举类，用来规定电梯的各种动作。</p><p>顺带一提，生活中绝大多数的电梯执行的都是LOOK策略。</p><p>此外，笔者还实现了电梯<del>踹人</del>的策略，也就是在同方向上，若是电梯已满，且门外有优先级比电梯内高的请求，两者交换一下。第一次作业没有<code>RECEIVE</code>的要求，该方案实现起来非常简单。</p><h3 id="代码量和类复杂度分析"><a href="#代码量和类复杂度分析" class="headerlink" title="代码量和类复杂度分析"></a>代码量和类复杂度分析</h3><p><img src="/img/OO-Unit2/Code_fifth.png" alt="第一次作业代码量"></p><p>第一次作业的代码量整体比较少，集中在<code>Elevator</code>类和<code>QuestTable</code>类中。</p><p><img src="/img/OO-Unit2/Magnanimity_fifth.png" alt="第一次作业OO度量"></p><p><code>Elevator</code>类，<code>QuestTable</code>类和<code>Scheduler</code>类的复杂度都比较高。其中<code>Elevator.run()</code>中有<code>while</code>循环和大量<code>if</code>条件判断，而<code>Shceduler</code>类中的<code>existQuest</code>方法和<code>nextOperation</code>方法也是如此，所以复杂度比较高。</p><h3 id="值得注意的bug"><a href="#值得注意的bug" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>笔者在实现电梯的过程中没有什么印象深刻的bug，不过在互测中找到了别人的bug。我们知道，当我们对一个容器进行边遍历边移除的时候，会发生<code>ConcurrentModificationException</code>，因此我们需要使用迭代器来遍历。然而当<strong>两个线程同时对某个容器进行操作</strong>的时候，即使使用了迭代器，依然会有<code>CME</code>错误。因此，对共享类进行严格的线程安全保证是很重要的。</p><h2 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h2><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_sixth.png" alt="第六次作业类图"></p><p>类图如上图所示</p><p>这一次的作业整体要复杂一点，首先不再为每个乘客规定电梯了，其次对电梯也增加了临时调度请求，整体的复杂度很高，<del>笔者也几乎写了整个清明节假期</del></p><p>这一次加入了新的线程<code>Manager</code>，用来将每个请求分配给电梯。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>在浏览往届学长学姐的帖子的时候，偶然发现了这个学长的<a href="https://blog.csdn.net/weixin_73635758/article/details/137831524?spm=1001.2014.3001.5501">博客</a>，学到了一个经过合理建模后的打分算法，整体体验下来效果很好，不逊于影子电梯。主要逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的分数为电梯从当前楼层出发到接到乘客共运行的楼层数</span></span><br><span class="line"><span class="comment">//在QuestScheduler里取分数最低的电梯分配该乘客</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(Quest quest)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*乘客需求方向与电梯运行方向相同*/</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*电梯内人数+与电梯运行方向相同的剩余任务数&lt;电梯容量*/</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*电梯无需掉头即可接到乘客*/</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">/*电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//需要掉头</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">/*电梯运行一圈的楼层数-电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//电梯这趟接不到乘客</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*电梯接到乘客需要遍历的圈数x电梯运行一圈的楼层数-电梯当前楼层与乘客出发楼层之差的绝对值*/</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//乘客需求方向与电梯运行方向相反</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过笔者的优化，笔者将电梯运行一圈的楼层数做了一个期望计算，最后的结果约为9-10之间，最后选择了9。第六次作业的强侧得分为95.25分，整体结果还算满意。</p><p>除此以外，整体的调度算法没有改变，一个值得注意的点，就是本次作业的<code>RECEIVE</code>要求使得踢人的实现变得略有复杂，再经过长时间的优化而<del>一直出bug</del>之后，笔者<del>有点自暴自弃，干脆</del>放弃了此策略</p><p>另外有一个让人笑话的点，就是笔者没有想到可以在接收到<code>SCHE</code>时就把电梯内部的乘客放出，反而是让乘客全程跟着电梯跑去临时调度的目标楼层，浪费了一些性能分。</p><h3 id="代码量和复杂度分析"><a href="#代码量和复杂度分析" class="headerlink" title="代码量和复杂度分析"></a>代码量和复杂度分析</h3><p><img src="/img/OO-Unit2/Code_sixth.png" alt="第六次作业代码量"></p><p>可以看到本次作业的代码量一下子就上去了，最多的是在<code>Elevator</code>类里面，对于实现<code>RECEIVE</code>和<code>SCHE</code>花费了大量的精力和代码。</p><p><img src="/img/OO-Unit2/Magnanimity_sixth.png" alt="第六次作业复杂度"></p><p>通过复杂度也可以看出，<code>Elevator</code>类确实变得过于复杂，其中主要是打分算法有较多的条件判断等。而执行分配调度的<code>Manager</code>类也是如此。</p><h3 id="值得注意的bug-1"><a href="#值得注意的bug-1" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>本次主要的bug有一个，在中测结束前通过笔者的评测机发现了。有时候，电梯可能会同时输出一个<code>RECEIVE</code>和一个<code>SCHE-BEGIN</code>。最后检查发现是在执行临时调度的开始阶段，笔者把锁挂在了电梯身上，而不是未完成请求列表，这导致分配线程在此期间还可以房屋内未完成请求列表，并把一个请求分配给该电梯。而对于笔者的实现，输出<code>RECEIVE</code>是交给分配器的，因此会导致同时输出。</p><p>在互测中，笔者发现同房间同学的一个有趣的bug。该同学似乎为了追求性能，尽量在输出<code>SHCE-BEGIN</code>前多跑几层楼。因此，笔者构造了一个跨度较长的<code>SCHE</code>请求，把电梯卡在极限距离，让该电梯的相应<code>SCHE</code>时间超过规定时间了。</p><h2 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h2><h3 id="如何处理轿厢不碰撞"><a href="#如何处理轿厢不碰撞" class="headerlink" title="如何处理轿厢不碰撞"></a>如何处理轿厢不碰撞</h3><p>经历过前两次作业的<del>折磨</del>之后，这个问题其实很容易想到解决办法。笔者在电梯内部新建一个<code>TargetFloor</code>对象，对于同一个井道的两个电梯，它们共享这一个楼层。笔者令到达换乘层的电梯获取换乘层对象的锁，在离开该层时释放换乘层对象的锁。需要注意的是，到达与离开均以输出为标准</p><h3 id="如何实现双轿厢电梯"><a href="#如何实现双轿厢电梯" class="headerlink" title="如何实现双轿厢电梯"></a>如何实现双轿厢电梯</h3><p>笔者的实现十分的不优雅。</p><p>调度器分别把这个<code>update</code>请求交给A、B两部电梯，两部电梯同时开始改造，分别放出其内部的乘客、修改参数信息（最高到达楼层等），而这个过程中的<code>UPDATE-BEGIN</code>等，均由A电梯来进行输出，不过很快笔者就发现这样的实现是有问题的。</p><p>尽管两部电梯同时接受到了来自调度器的请求，但这不能保证两部电梯可以同时进行<code>UPDATE</code>，或者说<code>UPDATE</code>的进度能保持一样，这就导致了有可能当A电梯已经输出了<code>UPDATE-BEGIN</code>的时候，B电梯还在放出客人；或者当A电梯尚未输出<code>UPDATE-END</code>的时候，B电梯已经完成了改造，开始<code>RECEIVE</code>乘客了。</p><p>笔者最后采用了这样的方法：对于一个update的请求，其内部设置三个方法，分别是<code>UPDATE</code>的准备、开始和结束。每个方法要求两部电梯都执行一次，才会使得电梯同步进入下一阶段。其实更优雅的方法就是把输出也放置到这些方法中，但笔者没有更改。</p><h3 id="整体架构-2"><a href="#整体架构-2" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/img/OO-Unit2/ClassDiagram_seventh.png" alt="第七次作业类图"></p><p>类图如上所示，架构较上一次作业没有太大变化。</p><h3 id="代码量和复杂度分析-1"><a href="#代码量和复杂度分析-1" class="headerlink" title="代码量和复杂度分析"></a>代码量和复杂度分析</h3><p><img src="/img/OO-Unit2/Code_seventh.png" alt="第七次作业代码量"></p><p>第七次作业代码量突破了1000行，其实整体上还是有东西可以合并的，在代码块中有几处重复或者高度相似的代码段。主要集中在<code>Elevator</code>类里面。</p><p><img src="/img/OO-Unit2/Magnanimity_seventh.png" alt="第七次作业复杂度"></p><p>作业整体的复杂度也很高，集中在电梯、调度器等。为了迎合双轿厢电梯的改造，<code>Scheduler</code>，即电梯行为的指示器，复杂度也变高了。</p><h3 id="值得注意的bug-2"><a href="#值得注意的bug-2" class="headerlink" title="值得注意的bug"></a>值得注意的bug</h3><p>本次作业出现的有趣的bug都在开头部分交代了。在强测和互测中均没有跑出bug。</p><h2 id="同步块和锁"><a href="#同步块和锁" class="headerlink" title="同步块和锁"></a>同步块和锁</h2><p>本次作业中，笔者主要使用的都是<code>synchronized</code>关键字。在第六次作业的实现过程中，笔者初步尝试了使用读写锁，但是在自己评测的过程中出现了很多难以修复的<del>奇妙</del>bug，<del>遂作罢</del>，改回<code>synchronized</code>。另外，对于很多私有变量，我使用了<code>AtomicBoolean</code>以及<code>AtomicInteger</code>，降低了锁的使用频率。java保证了对这些变量的读写都是原子性的。</p><h2 id="bug以及debug方法"><a href="#bug以及debug方法" class="headerlink" title="bug以及debug方法"></a>bug以及debug方法</h2><p>本次电梯单元，笔者是无伤通关，强测互测均没有出现bug。对于debug，笔者有一些自己比较好用的方法：</p><ol><li>调试输出<br> 多线程的bug并不能稳定复现，而且也不能通过打断点的方法去debug，因此我们可以进行调试输出，也就是在一些关键地方输出一些能反映线程参数的信息。比如在线程结束时，让线程输出<code>end</code>等，这样可以观察有哪些线程可能没有正常结束，进而发现程序中的缺陷</li><li>代码走查<br> 代码走查指的是在代码写完之后通读代码全体，检查代码潜在的bug。笔者主要通过这种方法来寻找可能出现的线程不安全问题，也确实用这样的方法成功的查漏补缺了。</li><li>构造评测机<br> 自动化评测对于多线程问题来说，笔者认为是必要的。大量的测试点才有可能测出多线程项目中潜在的问题，人工构造的测试点并不总能很好的”压迫边界“。构造评测机方法，详情可以看笔者的<a href="http://oo.buaa.edu.cn/assignment/624/discussion/1691">讨论区帖子</a>，抑或是已经同步更新的<a href="https://www.oldjoy.top/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/">博客</a>。</li></ol><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>经历了面向对象和操作系统的<del>双重折磨</del>，笔者算是对多线程有了一点理解。对于多线程编程，同步与互斥，也就是线程安全，是多线程编程最核心的内容之一。</p><p>笔者在测试中没有发现自己的任何有关线程安全的bug，这主要归功于在开始学习多线程编程之前，笔者对线程问题进行了细致系统的学习。尽管如此，笔者也并不认为自己对线程安全已经完全掌握。本次作业并发程度并不高，共享资源并不复杂，尚且没有达到生活中常见的多线程问题（12306），只能说对多线程初窥门径。</p><h2 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h2><p>本次作业的核心架构没有离开多线程架构中经典的<strong>生产者-消费者模型</strong>，而经历了操作系统的学习之后，这样的模型其实还有更多、更复杂、同样很精巧的模型。</p><p>层次化设计要求编程者自顶向下对整个设计任务进行分层分块，并对每层每块分别建类实现。高层的类只关注抽象后的功能调用，而底层的类则负责每种功能的具体实现。这样的做法在降低每层代码的复杂度发同时也会增加程序的代码总量，所以应该合理平衡代码复杂度与代码量。</p><p>本次作业中，我的层次化设计整体还算比较好，每个类负责的功能比较单一，类间逻辑比较清晰。但其实还可以做的更好，有很多可以继续抽象的地方尚可优化。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OO_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab2_实验报告</title>
      <link href="/2025/04/11/OS-Lab2/BUAA-OS-Lab2%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/04/11/OS-Lab2/BUAA-OS-Lab2%20%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h2><blockquote><p>请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址，还是物理地址？</p></blockquote><p>C 语言中指针变量储存的地址是虚拟地址，汇编代码中 lw 和 sw 指令中使用的地址也是虚拟地址。</p><h2 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h2><blockquote><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的 &#x2F;usr&#x2F;include&#x2F;sys&#x2F;queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul></blockquote><ol><li><p>使用宏来实现链表的好处有以下几个方面：</p><ul><li>代码复用：宏可以使链表的定义和操作变得通用，不受特定数据类型的影响。通过宏，可以在不同的数据结构中重用相同的链表实现代码，只需简单地将链表节点中的数据类型进行替换即可。</li><li>类型无关性：宏允许链表操作与具体的存储类型无关，这意味着同一个宏定义可以用于创建存储不同类型数据的链表。</li><li>性能优势：宏在编译时会被直接替换为相应的代码，没有函数调用的开销。这可以减少程序运行时的性能损耗。</li></ul></li><li><p>阅读了系统中<code>queue.h</code>可以得到以下结论</p><ul><li>单项链表如果要插入到链表中间的某个位置，需要从头部遍历一遍才能找到相应的位置，这个事件复杂的是 O(n)；</li><li>而双向链表记录了元素的前驱和后继，它对于任意元素在任意给定位置的插入和删除操作时间复杂度都只有 O(1)；</li><li>循环列表本质和单向链表差不多</li></ul></li></ol><h2 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h2><blockquote><p>请阅读 include&#x2F;queue.h 以及 include&#x2F;pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125; lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link;</span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应当选择<code>C</code>。<br>关于<code>Page</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;  <span class="comment">/* free list link */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而关于<code>Page_LIST_entry_t</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">        struct &#123;                                                                \</span></span><br><span class="line"><span class="meta">                struct type *le_next;   <span class="comment">/* next element */</span>                      \</span></span><br><span class="line"><span class="meta">                struct type **le_prev;  <span class="comment">/* address of previous next element */</span>  \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h2><blockquote><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul></blockquote><p>在多进程环境中，每个进程都有自己的虚拟地址空间，这些地址空间通常是独立的。ASID用于在TLB中区分不同进程的页表项，确保每个进程只能访问自己的内存地址，从而实现进程间的隔离。</p><p>ASID使得操作系统在管理内存时更加灵活和高效。它允许操作系统为每个进程分配一个唯一的标识符，而不需要关心进程的具体虚拟地址空间布局，从而简化了内存管理的工作。</p><p>当CPU进行上下文切换时，如果没有ASID，则需要将TLB中的所有条目刷新，因为新的进程可能会使用相同的虚拟地址，而这些地址在TLB中可能映射到不同的物理地址。ASID允许TLB保留多个进程的条目，只有当切换到具有相同ASID的进程时才需要刷新相关的TLB条目，减少了不必要的刷新操作。</p><p>ASID 6 位，因此可以最多容纳 64 个不同的地址空间。</p><h2 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h2><blockquote><ul><li>tlb_invalidate 和 tlb_out 的调用关系？</li><li>请用一句话概括 tlb_invalidate 的作用。</li><li>逐行解释 tlb_out 中的汇编代码。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">    tlb_out((va &amp; ~GENMASK(PGSHIFT, <span class="number">0</span>)) | (asid &amp; (NASID - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是<code>tlb_invalidate</code>调用<code>tlb_out</code></p><p>逐行解释如下：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out) <span class="comment"># 标记这是一个叶子函数，即它不会调用其他函数，也不会保存其他寄存器的状态。</span></span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder </span><span class="comment"># 告诉汇编器不要对指令进行重新排序，确保指令按照写的顺序执行</span></span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI <span class="comment"># 将 CP0 寄存器中的 ENTRYHI（TLB 的键字段）内容复制到通用寄存器 t0 中，保存原始的 ENTRYHI 值</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">a0</span>, CP0_ENTRYHI <span class="comment"># 将传入的参数（a0 寄存器中的值）复制到 CP0 的 ENTRYHI 寄存器中，准备进行TLB操作</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.8: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbp </span><span class="comment"># 根据 EntryHi 中的 Key，查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 2: Fetch the probe result from CP0.Index */</span></span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t1</span>, CP0_INDEX <span class="comment"># 将 CP0 的 INDEX 寄存器内容（TLB 探测的结果）复制到通用寄存器 t1 中</span></span><br><span class="line">    <span class="meta">.set</span> reorder</span><br><span class="line">    <span class="keyword">bltz </span>   <span class="built_in">t1</span>, NO_SUCH_ENTRY <span class="comment"># 如果 TLB 中没有找到对应的条目，跳转到 NO_SUCH_ENTRY 标签</span></span><br><span class="line">    <span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYHI</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO0</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO1 <span class="comment"># 把 CP0_ENTRYHI，CP0_ENTRYLO 全部设为 0，为清空 TLB 做准备</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.8: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbwi </span><span class="comment"># 将此时 EntryHi 与 EntryLo 的值，也就是 0，写到索引指定的 TLB 表项中，完成清空</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="meta">.set</span> reorder</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">NO_SUCH_ENTRY:</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI <span class="comment"># 将之前保存的原始 ENTRYHI 值写回到 CP0 的 ENTRYHI 寄存器中，恢复上下文</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="built_in">ra</span> <span class="comment"># 返回</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><h2 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h2><p>三级页表页目录的基地址<br><code>&#123;PTbase[38:30], PTbase[38:30], PTbase[38:30], 12&#39;h0&#125;</code></p><p>映射到页目录自身的页目录项（自映射）<br><code>&#123;PTbase[38:30], PTbase[38:30], PTbase[38:30], PTbase[38:30], 3&#39;h0&#125;</code></p><h2 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h2><ol><li>CPU 发出访问指令: 用户进程执行内存访问。</li><li>查询 TLB: 硬件自动执行。</li><li>触发 TLB Miss (No 分支): 硬件检测到 TLB 未命中，跳转到内核 TLB Miss 处理程序。</li><li>根据页目录表和虚拟地址寻找页表项 &#x2F; 从页表中查找页表项: 主要由 <code>page_lookup</code> 函数实现。它遍历页目录和页表，查找对应的页表项 (PTE)。</li><li>页目录项&#x2F;页表项是否有效:<ul><li>否 (No 分支 - 页面&#x2F;页表不存在或无效):<ul><li>分配新页面&#x2F;页表: 可能涉及 <code>page_alloc</code> (分配物理页) 和 <code>page_insert</code> (建立映射，填写 PTE)。<em>（流程图简化了分配页表本身，Lab2 主要处理页面的分配和插入）</em></li></ul></li><li>是 (Yes 分支 - 找到有效 PTE): <code>page_lookup</code> 成功返回有效的 PTE。</li></ul></li><li>取出物理页号 PPN … 写入 TLB: 由 <code>_do_tlb_refill</code> 函数在 <code>page_lookup</code> 成功后，读取 PTE 信息，并使用特定 CPU 指令将映射关系写入硬件 TLB。</li><li>重新访问 &#x2F; 读取到 PPN 结合 offset 完成访问 (Yes 分支): TLB refill 完成后，指令重新执行，此时 TLB Hit，硬件使用 TLB 中的 PPN 完成地址翻译和访问。</li></ol><p><strong>核心关系</strong>: Lab2 中的 <code>do_tlb_refill</code>、<code>page_lookup</code>、<code>page_alloc</code>、<code>page_insert</code> 等函数共同构成了 CPU 访问流程图中 <strong>TLB Miss 发生后由软件执行的页表查找、页面分配（如果需要）、页表更新以及最终填充 TLB 的处理逻辑</strong>。</p><h2 id="Thinking-2-7"><a href="#Thinking-2-7" class="headerlink" title="Thinking 2.7"></a>Thinking 2.7</h2><ul><li>X86 体系结构中的内存管理机制<ul><li>通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。</li><li>逻辑地址由两部分构成，一部分是段选择器，一部分是偏移。</li><li>段选择符存放在段寄存器中，如CS（存放代码段选择符）、SS（存放堆栈段选择符）、DS（存放数据段选择符）和ES、FS、GS（一般也用来存放数据段选择符）等；</li><li>偏移与对应段描述符中的基地址相加就是线性地址。</li><li>操作系统创建全局描述符表和提供逻辑地址，之后的分段操作x86的CPU会自动完成，并找到对应的线性地址。</li><li>从线性地址到物理地址的转换是CPU自动完成的，转化时使用的Page Directory和Page Table等需要操作系统提供。</li></ul></li><li>X86 和 MIPS 在内存管理上的区别<ul><li>TLB不命中：<ul><li>MIPS触发TLB缺失和充填，然后CPU重新访问TLB</li><li>x86硬件MMU索引获得页框号，直接输出物理地址，MMU充填TLB加快下次访问速度</li></ul></li><li>分页方式不同：<ul><li>一种MIPS系统内部只有一种分页方式</li><li>x86的CPU支持三种分页模式</li></ul></li><li>逻辑地址不同：<ul><li>MIPS地址空间32位</li><li>x86支持64位逻辑地址，同时提供转换为32位定址选项</li></ul></li><li>段页式的不同：<ul><li>MIPS同时包含了段和段页式两种地址使用方式</li><li>在x86架构的保护模式下的内存管理中，分段是强制的，并不能关闭，而分页是可选的；</li></ul></li></ul></li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><ul><li><p>物理内存管理部分，我感觉难度相对适中。主要任务是填充链表宏定义和实现几个关键函数。</p><ul><li>链表宏：这部分的关键在于理解双向链表的原理。虽然填充本身不难，但在动手前需要仔细阅读多个相关文件中的代码，并结合已有的宏定义，才能准确把握传入参数的含义。</li><li>函数实现：这部分则要求对各个变量间的逻辑关系有清晰的认识，特别是要理解 ROUND 函数的作用以及页控制块（Page Control Block）及其内部变量的意义。只要理解了这些，依照代码注释中的提示来完成实现还是比较顺利的。</li></ul></li><li><p>虚拟内存管理部分，整体难度也感觉不算太高。</p><ul><li>核心在于掌握二级页表的工作机制，并熟悉相关的宏定义和函数调用方法。</li></ul></li><li><p>TLB 重填部分，需要编写的代码量不大。基本上是根据代码注释的要求，按部就班地完成指定的操作即可。</p></li></ul><p>总的来说，这次实验加深了我对操作系统内存管理机制的理解，尤其是在二级页表和地址转换的概念上有了更清晰的认识，尽管中间也遇到了一些理解上的挑战。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>面对庞大的现有代码库，我最初感到有些不知所措，直接上手完成任务确实困难。由于 Lab 2 的课下作业开始得比较晚，时间紧迫，我采取了先快速浏览一遍，然后就参照提示或模仿上下文代码来填充空白的策略。这种“依样画葫芦”的方式虽然让我较快地完成了任务，但明显感觉到自己对代码的理解并不深入。<br>意识到这一点后，在完成练习之后，我特意投入了大半天的时间。我结合指导书，从头到尾仔细研读了 pmap.c 文件中的每一个函数实现。同时，我也更细致地查看了相关的头文件，这不仅加深了我对 C 语言宏定义的理解，也让我对每个函数的功能和实现逻辑有了更清晰的认识，并为它们添加了自己的注释。在这个深入阅读和思考的过程中，许多之前模糊不清的地方豁然开朗，得到了合理的解释。后来通过与同学们的交流讨论，我对代码细节和内存管理机制的理解又得到了进一步的巩固和深化。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我会构建健壮的多线程电梯评测机</title>
      <link href="/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/"/>
      <url>/2025/04/08/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/%E6%88%91%E4%BC%9A%E6%9E%84%E5%BB%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B5%E6%A2%AF%E8%AF%84%E6%B5%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我会构建健壮的多线程电梯评测机-smiley"><a href="#我会构建健壮的多线程电梯评测机-smiley" class="headerlink" title="我会构建健壮的多线程电梯评测机:smiley:"></a>我会构建健壮的多线程电梯评测机:smiley:</h1><p>已同步更新至本人blog，欢迎大家来参观:blush:</p><p>对于像电梯这样的复杂的、行为不确定的并发系统，<strong>构建自动化、系统化、能够进行状态跟踪和规则检查的测试框架，是确保程序正确性、提高开发效率的必备手段</strong>。直接手动测试覆盖面有限，且难以复现并发问题。因此，构建一个自动化的、能够生成有强度数据的、能够精确判定正确性的评测机就显得尤为必要。<del>同学，你也不想你的代码被我们hack吧</del></p><p>在经历了 HW5 到 HW6 的迭代后，电梯系统的规则变得更加复杂。在此之前，我和舍友合力搭建了一套基于 Python 的自动化评测框架，希望能较为全面地测试电梯程序的健壮性和性能。经过了一次迭代，该评测机的性能和正确性能够做到更优。在此，我想分享一下这套评测机的核心思路和实现细节，希望能为大家提供一些参考</p><h2 id="一、-核心组件概览"><a href="#一、-核心组件概览" class="headerlink" title="一、 核心组件概览"></a>一、 核心组件概览</h2><p>我们的评测机主要由以下 Python 脚本构成：</p><ol><li><p><strong><code>generate_data.py</code></strong>: 负责生成符合要求的、具有不同侧重点和强度的测试输入数据 (<code>stdin.txt</code>)，包括乘客请求和临时调度 (SCHE) 请求</p></li><li><p><strong><code>validator.py</code></strong>: 核心验证逻辑所在。它读取输入数据，模拟电梯系统的预期行为，并逐行解析、验证程序的输出 (<code>stdout</code>) 是否符合指导书的所有正确性约束（时序、状态、规则等）</p></li><li><p><strong><code>run_test.py</code></strong>: 测试流程的“指挥官”。它负责调用数据生成器、在隔离环境中执行同学们的 Java 程序（通过官方提供的 <code>datainput.exe</code> 和 <code>java</code> 命令）、捕获输出、调用验证器进行判定，并最终汇总、报告测试结果</p></li><li><p>**<code>run_elevator_tests.bat</code> **: 一个简单的启动脚本，方便一键运行</p><p><img src="/img/Elevator-tester/composition.png" alt="核心组件"></p></li></ol><h2 id="二、-数据生成策略-generate-data-py"><a href="#二、-数据生成策略-generate-data-py" class="headerlink" title="二、 数据生成策略 (generate_data.py)"></a>二、 数据生成策略 (<code>generate_data.py</code>)</h2><p>生成高质量的测试数据是评测有效性的基础。我们的目标是覆盖各种边界情况和压力场景:smiling_imp:</p><p>这是保证我们评测机强度的核心了。之前我在高强度水群的时候发现，某位同学说ta的评测机跑了一整天全是AC </p><p>那当然是测试点强度还不够啦！尽管是随机生成，我们也要有策略、有侧重点地随机生成，不给点压力，你怎么知道代码会不会垮掉呢？<del>嘻嘻</del></p><p><strong>核心思路：分阶段、有侧重地生成请求。</strong></p><p>我们将总的模拟时间（公测约 60s+，互测 50s）划分为四个阶段，每个阶段投放不同特点的请求：</p><ul><li><strong>阶段一 (0% - 15% 时间, ~10% 请求): 稀疏试探</strong><ul><li><strong>目的</strong>: 模拟系统启动初期或低峰期，请求零散</li><li><strong>内容</strong>: 生成少量乘客请求，优先级随机偏低，并夹杂少量 SCHE 请求。测试电梯的启动、基本寻路和 SCHE 响应能力</li></ul></li><li><strong>阶段二 (15% - 50% 时间, ~40% 请求): 密集压力 I</strong><ul><li><strong>目的</strong>: 模拟高峰期，测试系统的吞吐能力和调度策略在高负载下的表现，<del>就好比下课时间大家蜂拥去食堂</del></li><li><strong>内容</strong>: 大量乘客请求涌入，时间戳<strong>相近</strong>或<strong>相同</strong>。乘客请求可能跨度较大。也包含一些 SCHE 请求，测试调度中断和恢复能力</li></ul></li><li><strong>阶段三 (50% - 75% 时间, ~20% 请求): 边界与特殊场景</strong><ul><li><strong>目的</strong>: 专门测试指导书中提到的或容易出错的边界情况</li><li><strong>内容</strong>:<ul><li><strong>极端距离</strong>: 如 B4 &lt;-&gt; F7。</li><li><strong>跨零层</strong>: 如 B1 &lt;-&gt; F1。</li><li><strong>短距离</strong>: 相邻楼层。</li><li><strong>SCHE 边界</strong>: 测试 SCHE 请求与普通请求的交互、SCHE 的快速响应、SCHE 期间乘客处理、完成 SCHE 需要的总时间等。生成 SCHE 请求时，会保守估计上一个 SCHE 的完成时间，确保两次 SCHE 之间有足够间隔</li></ul></li></ul></li><li><strong>阶段四 (75% - 100% 时间, ~30% 请求): 优先级与密集压力 II</strong><ul><li><strong>目的</strong>: 测试调度策略对优先级的响应，以及在接近结束时处理剩余请求的能力。很多同学想必都对优先级进行过优化，那么自然要有针对性的找问题，<del>桀桀桀</del></li><li><strong>内容</strong>: 生成大量同时间戳请求，这些请求中有极高优先级 (80-100) 和极低优先级 (1-10) 的请求，集中hack同学们针对优先级优化的地方。同时保持一定的请求密度。也包含 SCHE 请求</li></ul></li></ul><p><strong>其他生成细节:</strong></p><ul><li><strong>互测模式约束</strong>: 当检测到是互测模式时：<ul><li>最大数据投喂时间强制设为 50s</li><li>总请求数（乘客 + SCHE）严格控制在 70 条以内</li><li>每部电梯的 SCHE 请求数严格控制在 1 次以内</li></ul></li><li><strong>时间戳</strong>:<ul><li>保证第一条指令 <code>&gt;= 1.0s</code></li><li>使用插入并最后排序，确保输入文件中的精确时间戳<strong>非递减</strong></li><li>在最终输出到 <code>stdin.txt</code> 时，检查确保格式化后的时间戳也是<strong>非递减</strong>的（通过与上一个输出的时间戳比较调整）</li><li>添加微小随机扰动，避免大量完全相同的时间戳</li></ul></li></ul><h2 id="三、-正确性判定-validator-py"><a href="#三、-正确性判定-validator-py" class="headerlink" title="三、 正确性判定 (validator.py)"></a>三、 正确性判定 (<code>validator.py</code>)</h2><p>这是评测机的核心和最复杂的部分。它的运行思路是<strong>基于学生程序的输出日志，精确模拟电梯和乘客的状态变化，并根据指导书的所有规则进行校验</strong>，<del>当然，这也是和大模型经过深刻交流后诞生的</del></p><p><strong>核心思路：状态机模拟 + 规则校验</strong></p><ol><li><p><strong>状态建模</strong>:</p><ul><li><code>PassengerState</code><strong>乘客状态</strong>: 记录每个乘客的 ID, 优先级, 起止楼层, 请求时间, <strong>当前位置</strong>, 当前状态, <strong>所在电梯</strong>, 以及<strong>被哪个电梯接收</strong></li><li><code>ElevatorState</code><strong>电梯状态</strong>: 记录电梯 ID, 当前楼层, 门状态, <strong>轿厢内乘客集合</strong>, <strong>已接收待处理乘客集合</strong>, 当前速度, <strong>调度状态</strong>, 临时调度信息, 以及<strong>上次动作完成时间</strong> 用于时序检查。</li></ul></li><li><p><strong>输出解析</strong>:</p><ul><li>逐行读取 <code>stdout</code>。</li><li>使用正则表达式精确匹配时间戳和事件内容。采用 <code>re.fullmatch</code> 确保内容完全符合预期格式。</li><li>解析出事件类型和参数（楼层、ID、速度等），进行基本类型和范围检查（如楼层是否有效，ID 是否在 1-6）。</li><li>时间戳检查: 全局检查输出时间戳是否非递减。</li></ul></li><li><p><strong>事件验证</strong>: 这个是正确性判定的关键了。对每个解析出的事件，根据当前模拟的系统状态（所有电梯和乘客的状态）和指导书规则进行检查：</p><ul><li><p><strong>基本移动 (<code>ARRIVE</code>)</strong>:</p><ul><li>检查门是否关闭</li><li>检查时间是否满足 <code>当前速度 * 1 层</code> 的要求（与上次动作完成时间比较，允许一定误差）</li><li>检查移动是否合法（相邻楼层或跨零层）</li><li>检查电梯在空闲时（无乘客、无接收）是否在 <code>RECEIVE</code> 后才移动（基础检查）</li></ul></li><li><p><strong>开关门 (<code>OPEN</code>&#x2F;<code>CLOSE</code>)</strong>:</p><ul><li>检查前置状态<del>开门前必须关门，关门前必须开门</del></li><li>检查是否在当前楼层操作</li><li>检查 <code>CLOSE</code> 距离对应的 <code>OPEN</code> 是否满足最小开门时间（普通 <code>0.4s</code>，SCHE 目标层 <code>1.0s</code>）</li></ul></li><li><p><strong>进出乘客 (<code>IN</code>&#x2F;<code>OUT</code>)</strong>:</p><ul><li>检查门是否打开</li><li>检查是否在电梯当前楼层</li><li><code>IN</code>: 检查电梯容量是否合法；检查乘客是否在当前楼层；<strong>检查乘客是否已被该电梯 <code>RECEIVE</code></strong>；<em>重要：<code>IN</code> 在电梯处于调度状态下禁止</em>。</li><li><code>OUT</code>: 检查乘客是否在该电梯内部；根据 <code>OUT-S</code>&#x2F;<code>OUT-F</code> 和是否到达目的地判断标志是否正确</li><li>状态更新：正确更新乘客的状态，包括所处楼层或所处电梯等</li></ul></li><li><p><strong>接收 (<code>RECEIVE</code>)</strong>:</p><ul><li><p>检查乘客是否处于等待电梯的状态中</p></li><li><p>检查乘客是否已被<strong>其他</strong>电梯接收</p></li><li><p>检查是否<strong>重复接收</strong>同一乘客</p><p>举个例子，下面是判定接受成功的部分代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function validate_receive(event):</span><br><span class="line">passenger = get_passenger(event.person_id)</span><br><span class="line">elevator = get_elevator(event.elevator_id)</span><br><span class="line">is_sche_active = (elevator.scheduling_state == ACTIVE)</span><br><span class="line"></span><br><span class="line">if is_sche_active://电梯仍在SCHE中</span><br><span class="line">    add_error(&quot;RECEIVE during SCHE ACTIVE&quot;)</span><br><span class="line">if passenger.state != WAITING: //乘客不属于等待状态（未投喂请求、已进入电梯等）</span><br><span class="line">    add_error(&quot;RECEIVE Passenger not WAITING&quot;)</span><br><span class="line">// 关键：检查是否已被任何电梯接收 (包括自己)</span><br><span class="line">if passenger.received_by_elevator != -1:</span><br><span class="line">     if passenger.received_by_elevator != event.elevator_id:</span><br><span class="line">         add_error(&quot;Passenger already received by another elevator&quot;)</span><br><span class="line">     else:</span><br><span class="line">         add_error(&quot;Duplicate RECEIVE by same elevator&quot;)</span><br><span class="line"></span><br><span class="line">// 如果检查通过:</span><br><span class="line">passenger.received_by_elevator = event.elevator_id</span><br><span class="line">elevator.received_passengers.add(event.person_id)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>临时调度 (<code>SCHE-ACCEPT</code>, <code>SCHE-BEGIN</code>, <code>SCHE-END</code>)</strong>:</p><ul><li><code>SCHE-ACCEPT</code>: 从输出解析，更新电梯状态为，记录调度信息（允许覆盖）。</li><li><code>SCHE-BEGIN</code>: 检查电梯是否处于接受调度状态；检查门是否关闭；检查电梯是否静止；检查距离 <code>SCHE-ACCEPT</code> 的 <code>ARRIVE</code> 次数 (<code>&lt;= 2</code>)；<strong>关键：将该电梯所有的已经<code>RECEIVE</code>到的乘客状态设为未接收，并清空电梯的“已RECEIVE乘客”集合</strong>；设置状态为处于临时调度中，更新运行速度。</li><li><code>SCHE-END</code>: <strong>检查电梯是否处于临时调度中</strong>；检查电梯是否在目标楼层；检查是否空载；检查门是否 <code>CLOSED</code>；检查总响应时间（不能超过6s）；检查之前是否有合法的 <code>OPEN</code> -&gt; (等待1s) -&gt; <code>CLOSE</code> 序列；设置状态为正常，恢复默认速度。</li></ul></li></ul></li><li><p><strong>最终状态检查</strong>:</p><ul><li>所有乘客状态是否为 <code>ARRIVED</code>。</li><li>所有电梯状态是否为 <code>IDLE</code>，是否空载，门是否 <code>CLOSED</code>，速度是否恢复默认。</li></ul></li></ol><h2 id="四、-自动化与执行流程-run-test-py"><a href="#四、-自动化与执行流程-run-test-py" class="headerlink" title="四、 自动化与执行流程 (run_test.py)"></a>四、 自动化与执行流程 (<code>run_test.py</code>)</h2><p>为了方便、高效地进行大量测试，自动化流程必不可少，你也很喜欢点点鼠标就自动开始评测对吧:yum:</p><ol><li><p><strong>模式选择</strong>: 启动时询问用户选择“公测”或“互测”模式，加载对应的参数（如最大请求投喂时间，数据生成范围等）</p></li><li><p><strong>并行测试</strong>: 使用 <code>concurrent.futures.ProcessPoolExecutor</code> 并行运行多个测试实例，显著缩短总测试时间</p></li><li><p><strong>环境隔离</strong>:</p><ul><li>为每个测试实例创建一个独立的子目录</li><li>将学生的代码 JAR包、官方的JAR包和数据投喂包复制到子目录中</li><li>在该子目录中生成独立的 <code>stdin.txt</code></li><li><strong>作用</strong>: 防止不同测试实例之间因共享文件或状态产生干扰，确保测试的可重复性</li></ul></li><li><p><strong>命令执行与 I&#x2F;O</strong>:</p><ul><li>使用 <code>subprocess.Popen</code> 在子目录中执行数据投喂命令</li><li>通过管道捕获 Java 程序的 <code>stdout</code> 和 <code>stderr</code></li><li>设置超时 (<code>timeout</code> 参数)，在超时后将超时判断设置为真</li></ul></li><li><p><strong>超时处理</strong>: 即使进程超时，仍会<strong>尝试读取已有的输出</strong>，并<strong>继续执行验证逻辑</strong>。最终结果会被标记为 <code>FAIL_TIMEOUT</code>，但日志中会包含验证器对部分输出的检查结果，有助于分析超时前的行为。</p></li><li><p><strong>Stderr 检查</strong>: 严格检查 <code>stderr</code> 是否有任何输出。根据指导书要求，任何 <code>stderr</code> 输出都视为错误</p></li><li><p><strong>结果汇总与报告</strong>:</p><ul><li>收集每个测试的状态 (<code>PASS</code>, <code>FAIL_VALIDATE</code>, <code>FAIL_TIMEOUT</code>, <code>FAIL_JAVA_ERROR</code>, <code>FAIL_STDERR_OUTPUT</code> 等)</li><li>计算通过率，清晰地列出失败的测试点及其主要原因</li><li>对于失败的测试点，<strong>自动保存</strong>其输入数据 (<code>failed_data_...txt</code>) 和详细日志 (<code>failed_stdout_...txt</code>) 到 <code>test_results_hw6</code> 目录。日志中包含：测试信息、stdin、stdout、stderr、以及 <code>validator.py</code> 报告的所有错误信息和 <strong>Traceback (用于调试评测机本身)</strong></li></ul></li><li><p><strong>自动清理</strong>: 测试结束后，自动删除所有临时的子目录。在开始新一轮测试前，也会清理旧的结果目录 <code>test_results_hw6</code></p><p><img src="/img/Elevator-tester/result.png" alt="评测结果"></p></li></ol><h2 id="五、-总结与思考"><a href="#五、-总结与思考" class="headerlink" title="五、 总结与思考"></a>五、 总结与思考</h2><p>这套评测框架旨在通过<strong>自动化、并行化、多阶段数据生成、精细化状态模拟和严格规则校验</strong>，尽可能全面地测试多线程电梯程序的正确性，事实上，两次作业我用这个评测机找到了程序中很多隐蔽的bug，并在互测中成功击落了几个大佬的程序，战绩可查:sunglasses:</p><p><strong>优点</strong>:</p><ul><li><p><strong>自动化程度高</strong>: 一键运行，自动生成数据、执行、判定、报告、清理</p></li><li><p><strong>测试效率高</strong>: 并行执行大大缩短了测试时间，经过舍友的优化，一键脚本支持多个JAR包同时开跑，<del>晚上睡觉前把房间里所有同学的代码都打包好然后狠狠跑他5000组数据</del>，大大提高了评测效率</p><p><img src="/img/Elevator-tester/condition.png" alt="评测现状"></p></li><li><p><strong>数据有针对性</strong>: 分阶段生成数据，兼顾了压力和边界情况</p></li><li><p><strong>判定较严格</strong>: 尽可能覆盖了指导书中的显式和隐式规则。</p></li></ul><p><strong>待改进之处</strong>:</p><ul><li><strong>性能分计算</strong>: 当前验证器只计算了性能分的三要素 (<code>T_run</code>, <code>WT</code>, <code>W</code>)，并未实现指导书中复杂的相对评分公式。</li><li><strong>“Quantum Elevator” 检测</strong>: 精确检测<code>电梯空闲状态下收到RECEIVE后未等待0.4s即ARRIVE</code>需要复杂的状态回溯，目前实现是近似的，可能存在少量误判或漏判。</li><li><strong>SCHE 间隔保证</strong>: 数据生成器中对两次 SCHE 间隔的保证是基于一个保守的固定时间估计，而非精确模拟，理论上仍有小概率生成不合规数据（尽管指导书保证输入数据是合理的）。</li><li><strong>验证器复杂度</strong>: <code>validator.py</code> 逻辑复杂，自身也可能存在未发现的 bug。</li></ul><p>总而言之，搭建这样一个评测机本身就是一次很好的面向对象设计和多方面考虑的练习。希望这个思路分享能对大家有所启发，也欢迎交流和指出其中的不足之处！</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OO_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_Unit1_单元总结</title>
      <link href="/2025/03/28/OO-Unit1%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83/"/>
      <url>/2025/03/28/OO-Unit1%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="「BUAA-OO」第一单元总结"><a href="#「BUAA-OO」第一单元总结" class="headerlink" title="「BUAA OO」第一单元总结"></a>「BUAA OO」第一单元总结</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>使用MetricsReload插件对我的项目进行分析，得到类的复杂度如下图所示，整体来看，主要复杂度高的地方在第二次作业和第三次作业迭代的地方，这也与我设计上有所欠缺有关。<br><img src="/img/OO-Unit1/magnanimity.png" alt="OO度量"></p><p><strong>架构优点</strong></p><ul><li>分类明确。每个类都处理好自己的工作，相互没有过多交集，所有的<code>get</code>方法我都是返回一个映射而非返回类成员本身，符合面向对象封装的思想。</li><li>可迭代性好。整体的迭代工作并不困难。</li></ul><p><strong>架构缺点</strong></p><ul><li>可读性差。在函数因子<code>FuncFactor</code>与函数定义<code>FuncCall</code>里面，在参数处理方面，我写了很大的<code>if - else</code>分支，导致了代码可读性很差，而且这样很容易漏掉一些情况，这也与我强测寄了有一定的联系</li><li>重复性高。出于一些原因<del>其实就是懒</del>，我没有对代码进行重构，导致在递推函数<code>FuncFactor</code>和普通函数<code>SimpleFuncFactor</code>里面存在大量的代码重复，没有提炼成合理的方法，确实是不可取的地方。</li></ul><p>类图如下</p><p><img src="/img/OO-Unit1/ClassDiagram.png" alt="类图"></p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>设计思路上，我套用了之前OOpre的第七次作业给的递归下降的模版，从表达式逐层下降解析，直到把整个表达式解析完成。在预处理和最后的化简阶段，我使用了一些正则表达式的知识，比如匹配并去除空白字符、匹配多余的<code>+</code>号，还有在输出之前去掉多余的<code>^1</code>等等。</p><p>而关于中间的单项式与多项式，第一次作业表达式的结果一定是<br>$$<br>\displaystyle \sum a \cdot x^n<br>$$<br>所以，运算中的单个结果一定是<br>$$<br>a \cdot x^n<br>$$<br>因此，我构建了一个类名为<code>Unit</code>，还有一个类名为<code>Poly</code>，用来处理单项式与多项式。而表达式、项、各种因子里面也有一个<code>toPoly</code>方法，用来把已经解析完成的表达式转换成多项式以供运算和输出。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>本次作业整体比较简单，除了删去多余的<code>^1</code>、乘号等，我还发现，可以尽量把正项放在前面，这样就可以省略一个<code>+</code>的长度。除此之外我没有想到什么可行的优化方案。事实也证明是这样，在强测中，我得到了100分。</p><h3 id="hack思路"><a href="#hack思路" class="headerlink" title="hack思路"></a>hack思路</h3><p>本次hack是比较<del>艰难</del>的，因为大家好像都没有什么bug。我在hack中多数依赖随机生成的测试点进行测试。只有一位同学的代码让我的评测机产生了报错，但是在将测试点复制到IDEA里面进行本地运行的时候却没有问题。直到后来我在观察这位同学的代码时，我才发现这个同学在处理输入的最后一个空白字符时会产生空指针，而我在复制测试点时只会复制到最后一个有效字符，确实是疏忽了。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h3><p>本次作业可谓是一个滑铁卢。在最开始设计的时候，我没有想到什么特别清晰的处理方法。最开始时，我试图使用字符串替换递推函数的方法，中间使用正则表达式来匹配。但是经过了一段时间的努力之后，我发现这样的做法存在着很大的弊端。于是后来，在和朋友们交流之后，我重新构建了递推函数的部分，先使用<strong>静态方法</strong>把定义式解析后，记录下对应位置的形参，然后在递推函数因子的<code>toPoly</code>方法里面，将形参和实参进行替换并计算。整体的思路是比较清晰的，但是因为时间原因，也没有进行完整的、足够的测试，最终少考虑了很多情况，在强测中得到了比较低的分数。</p><p>但是上次的设计思路依旧可取，不过形式需要转换一下，毕竟加入了新的三角函数等。然而在合并同类项的时候，我的设计整体比较奇怪</p><p><img src="/img/OO-Unit1/Unit.png" alt="Unit"></p><p>如图，明明<code>Poly</code>是由<code>Unit</code>组成的，但是<code>Unit</code>的成员里面却有着<code>Poly</code>，导致我在判断两个三角函数表达式是否相等时出了点问题，我重写了几次<code>hashCode</code>方法效果都不理想，最后干脆直接<code>toString</code>比较字符串了，效果居然还不错，但是在遇到一些刻意的不同形式的等价表达式，这种判断方法就不够用了。</p><h3 id="debug思路"><a href="#debug思路" class="headerlink" title="debug思路"></a>debug思路</h3><p>本次作业最主要的问题是情况考虑的不周到，忽视了递推函数中参数为三角函数因子的情况。所以在最终的debug过程中，我做的最多的其实是补充<code>if - else</code>分支，解决被忽视的情况。另外，我还更改了上次作业遗留的问题。在上次作业中，如果在表达式开头或者<code>(</code>之后直接跟了一个负号，我会主动添加一个0，把它改编成<code>0-</code>但是这样存在问题，如果函数因子为一个负常数，会导致这个负常数变成了一个表达式，进而解析就会出现问题，所以最后是把解析常数因子的部分修改成可以判断负号了。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="设计思路-2"><a href="#设计思路-2" class="headerlink" title="设计思路"></a>设计思路</h3><p>设计思路依然延续上两次作业的架构，新增了求导因子和普通函数因子。普通函数因子仅在最初定义时和递推函数有所不同，所以其实可以再把二者定义一个接口，把方法再精炼一下。</p><p>求导的实现也是使用了递归的思路，我把求导的方法添加到了<code>Factor</code>接口里面，同时也添加了<code>clone</code>方法，实现深克隆，避免修改原来实例化了的类。</p><h3 id="debug思路-1"><a href="#debug思路-1" class="headerlink" title="debug思路"></a>debug思路</h3><p>经过了上一次作业的痛苦教训，我尽力考虑周全了所有的情况，然而在一个不起眼的地方，我失误将返回的类定义为了<code>Expr</code>类。然而在我的处理中，处于内层的表达式都应当使用<code>SubExpr</code>类，所以当出现递推函数调用普通函数进行定义的时候，会产生参数替换失败的情况，也就是<code>f&#123;1&#125; = g(h(x^2))</code>这样的情况，我会解析成<code>f&#123;1&#125; = g(h(x))</code>，产生了一些bug，使我强测失去了一点分数。</p><h3 id="hack思路-1"><a href="#hack思路-1" class="headerlink" title="hack思路"></a>hack思路</h3><p>在hack开放之前，我先列下了一众大家可能会忽视的输入形式，比如函数嵌套调用、对三角函数嵌套求导等，然后人工捏了很多压力测试点，在hack开放后，对整个房间里的所有代码进行同步测试，最后确实发现了很多错误。</p><h2 id="可能的迭代需求"><a href="#可能的迭代需求" class="headerlink" title="可能的迭代需求"></a>可能的迭代需求</h2><p>可以发现，有很多的表达式形式都没有考虑到，比如指数函数、对数函数等等。以指数函数为例。两个底数相同的指数函数在相乘的时候，其底数不变、指数相加，那么在多项式乘法的方法里就要增加对指数函数相乘的处理：</p><ol><li>判断底数是否相同</li><li>将指数进行相加</li></ol><p>对数函数的处理也是类似的。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>本次作业我没有做特别多的优化，主要的优化在三角函数特殊值判断上面，比如运算中出现sin(0)，cos(0)等等，另外我尝试做了一下cos^2+sin^2的优化，不过只能在比较简单的条件下进行判断。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本次作业确实让我体会到了面向对象编程的奇妙之处。荣文戈老师的理论课也让我启发颇多。封装、多态的思想确实是面向对象的重要特点，也是面向对象编程有趣的地方。表达式的解析、递归下降，把每一项任务逐步下放到每个类中，每个类不向外界展示自己的“隐私”，让代码的运行变得清晰而有迹可循。</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>对于课程未来的方向，我觉得可以适当给予更多的时间以供大家对自己的架构进行更充足的优化，对自己的代码予以更充分的检查。另外，建议课程开展一个类似额外补充的项目，指导大家如何搭建属于自己的评测机，可以给一些合理的数据生成思路等。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OO_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab1_实验报告</title>
      <link href="/2025/03/28/OS-Lab1/OS-Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/28/OS-Lab1/OS-Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h2><blockquote><p>在阅读 附录中的编译链接详解 以及本章内容后，尝试分别使用实验环境中<br>的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有<br>mips-linux-gnu- 前缀，如 mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编<br>译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p></blockquote><p>指导书中提到的objdump指令为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>-D</code>表示：反汇编（Disassemble）那些预计包含指令的<strong>所有</strong>节区。</li><li><code>-S</code>表示：在反汇编输出中，尽可能地将源代码（如果编译时包含了调试信息，通常是使用 gcc -g 编译）与汇编代码交错显示。这对于理解某段汇编代码对应哪行 C&#x2F;C++ 源代码非常有帮助。通常需要与<code>-d</code>或<code>-D</code>一起使用。</li><li><code>-d</code>表示：反汇编那些预计包含指令的<strong>代码</strong>节区。</li></ul><p>首先，编写一个简单的程序<code>helloworld.c</code>，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>mips-linux-gnu-gcc -E helloworld.c &gt; temp</code>命令，只进行预处理，不进行编译和操作，找到文件末尾的位置，如图所示</p><p><img src="/img/OS-Lab1/preprocessing.png" alt="预处理"></p><p>预处理只不过是将头文件展开，替换成相应的代码，并没有任何编译和链接</p><p>依次执行下面两个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -c helloworld.c</span><br><span class="line">mips-linux-gnu-objdump -DS helloworld.o &gt; temp</span><br></pre></td></tr></table></figure><p>这两个命令分别是针对MIPS架构的交叉编译和反汇编操作</p><p>第一个命令是使用交叉编译器<code>mips-linux-gun-gcc</code>对<code>helloworld.c</code>文件进行编译，最终会生成目标文件<code>helloworld.o</code><br>第二个命令是使用<code>mips-linux-gnu-objdump</code>工具对目标文件<code>helloworld.o</code>进行反汇编，并将结果输出到<code>temp</code>中</p><p>最终结果如图</p><p><img src="/img/OS-Lab1/disassemble.png" alt="反汇编"></p><p>我们发现反汇编的结果中包含了源代码中定义的变量和函数</p><p>再执行下面两个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -o helloworld helloworld.c</span><br><span class="line">mips-linux-gnu-objdump -DS helloworld &gt; temp</span><br></pre></td></tr></table></figure><p>这两个命令是用于编译和反汇编 MIPS 架构程序的操作</p><p>第一个命令是使用交叉编译器<code>mips-linux-gun-gcc</code>对<code>helloworld.c</code>文件进行编译，生成可执行文件<code>helloworld</code><br>第二个命令是使用<code>mips-linux-gnu-objdump</code>工具对名为<code>helloworld</code>的可执行文件进行反汇编，并将反汇编结果输出到<code>temp</code>中</p><p><img src="/img/OS-Lab1/disassemble2.png" alt="反汇编2"></p><p>我们发现<code>main</code>函数被分配到了<code>00400650</code>的地址上</p><p>查阅相关资料后，我们知道：<br>如果只编译不链接</p><ol><li>生成目标文件（.o 文件），包含了编译后的机器代码和符号表信息，但还没有进行符号解析和地址重定位</li><li>如果涉及多个源文件，每个源文件都会生成对应的目标文件，但它们并未合并在一起</li></ol><p>编译并连接</p><ol><li>将各个目标文件连接在一起，解析符号引用，填充地址空间，并生成最终的可执行文件</li><li>在链接过程中，可能还会包含库文件、共享对象等，以及进行符号解析和地址重定位</li></ol><h2 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h2><blockquote><p>思考下述问题：</p><ul><li>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文<br>件。<blockquote><ul><li>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚<br>才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf<br>-h，并阅读 tools&#x2F;readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</li></ul></blockquote></li></ul></blockquote><p>运行<code>./tools/readelf/readelf ./target/mos</code>指令，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:0x0</span><br><span class="line">1:0x80010000</span><br><span class="line">2:0x80011cc0</span><br><span class="line">3:0x80011cd8</span><br><span class="line">4:0x80011cf0</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br></pre></td></tr></table></figure><p>我们得到了一系列的地址信息。但当我们用readelf程序去解析自身，却发现无法成功。这是因为我们编写的 readelf 程序仅支持解析<strong>32</strong>位 ELF 文件，而程序自身实际上是一个<strong>64</strong>位的 ELF 文件。</p><p>我们用<code>readelf -h</code>命令分别对<code>hello</code>和<code>readelf</code>文件进行头部信息解析。<code>hello</code>文件结果显示为<code>ELF32</code>，而<code>readelf</code>文件则显示为<code>ELF64</code></p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p>本次实验主要分为内核初始化阶段的底层配置和用户功能模块开发两个部分。在系统启动环节中，我们重点进行了内核地址空间的重新规划与启动流程的汇编级实现。这需要结合工程中的多维度技术文档，特别是通过解析内存映射示意图来修正链接脚本(kernel.lds)中的段地址参数，同时需要深入理解平台相关的宏定义体系，才能准确完成start.S中关键寄存器的初始化配置。虽然这部分基础代码量不大，但涉及到底层硬件与编译工具链的深度协同，需要建立完整的地址空间映射认知</p><p>在功能开发层面，实验包含两个特色模块的实现。首先是类readelf工具的核心功能仿真，虽然需要补全的代码片段有限，但整个工程架构涉及ELF文件格式解析的完整处理流程。为此必须仔细研读工程中预定义的节头表、程序头表等数据结构，并理解各字段在二进制解析过程中的动态填充机制。其次是内核级日志输出系统printk的完善，该任务虽然只需在现有框架内补充少量格式化处理逻辑，但要真正掌握其设计精髓，需要通盘分析可变参数处理机制、字符缓冲管理策略以及终端驱动接口的调用层级。特别值得注意的是，三个关联文件之间的数据流向和函数调用关系构成了完整的输出处理链条，这对理解操作系统内核的模块化设计思想具有重要价值</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>这次实验，我们整体的工作量并不是很大，难度也不高。但是比较重要的一点是我们要仔细阅读给出的代码，把握细节。把架构理清楚，代码的编写和补全就很轻松了。在补全代码的同时，我也学到了很多更有趣的c代码编写方式，也算是给我带来了更高端的代码编写细则</p><h1 id="原创说明"><a href="#原创说明" class="headerlink" title="原创说明"></a>原创说明</h1><p>本次实验报告参考了<a href="https://buaaczx.github.io/posts/20240712-os-lab1/">czx学长</a>和<a href="https://yanna-zy.github.io/2023/03/19/BUAA-OS-1/">zy学姐</a>的博客</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0_实验报告</title>
      <link href="/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/11/OS-Lab0/OS-Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h2><p>执行<code>git status &gt; Untracked.txt</code>，是查询当前<code>README.txt</code>的文件状态，并将其记录在<code>Untracked.txt</code>文件中。后续两个命令同理。</p><p>执行完<code>cat Untracked.txt</code>后，显示出<code>未跟踪的文件</code>，说明文件刚刚新建的时候，其处于未跟踪的状态；执行<code>cat Stage.txt</code>后，显示出<code>要提交的变更</code>，说明修改了文件，并使用<code>add</code>命令之后，文件处于暂存的状态；执行<code>cat Modified.txt</code>之后，显示出<code>尚未暂存以备提交的变更</code>，说明文件再被修改之后，处于被修改状态。</p><h2 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h2><p>add the file 对应的是git中的<code>git add</code>命令</p><p>stage the file 对应的也是git中的<code>git add</code>命令</p><p>commit 对应的是git中的<code>git commit</code>命令</p><h2 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h2><ol><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm --cached hello.txt</code></li></ol><h2 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h2><p>第一次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture1.png" alt="图片1"></p><p>第二次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture2.png" alt="图片2"></p><p>第三次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture3.png" alt="图片3"></p><p>第四次<code>git log</code>如图所示</p><p><img src="/img/OS-Lab0/picture4.png" alt="图片4"></p><h2 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h2><p>执行<code>echo first</code>后如图</p><p><img src="/img/OS-Lab0/picture5.png" alt="图片5"></p><p>执行<code>echo second &gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture6.png" alt="图片6"></p><p>执行<code>echo third &gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture7.png" alt="图片7"></p><p>执行<code>echo forth &gt;&gt; output.txt</code>后如图</p><p><img src="/img/OS-Lab0/picture8.png" alt="图片8"></p><h2 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h2><p><code>command</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash                                                              <span class="built_in">touch</span> <span class="built_in">test</span></span></span><br><span class="line">echo &#x27;echo Shell Start...&#x27; &gt; test</span><br><span class="line">echo &#x27;echo set a = 1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;a=1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set b = 2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;b=2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo set c = a+b&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;c=$[$a+$b]&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo c = $c&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save c to ./file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $c&gt;file1&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save b to ./file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $b&gt;file2&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save a to ./file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo $a&gt;file3&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file1 file2 file3 to file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file1&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file2&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file3&gt;&gt;file4&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;echo save file4 to ./result&#x27; &gt;&gt; test</span><br><span class="line">echo &#x27;cat file4&gt;&gt;result&#x27; &gt;&gt; test</span><br></pre></td></tr></table></figure><p><code>result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><code>echo echo Shell Start</code>直接把<code>echo Shell Start</code>作为字符串输出；</li><li><code>echo (反顿号)echo Shell Start(反顿号)</code>是将<code>echo Shell Start</code>的<strong>输出</strong>作为外层echo的输入，所以会输出<code>Shell Start</code>；</li><li><code>echo echo $c&gt;file1</code>直接把<code>echo $c&gt;file</code>作为字符串输出；</li><li><code>echo (反顿号)echo $c&gt;file1(反顿号)</code>是将<code>echo $c&gt;file1</code>的<strong>输出</strong>作为外层echo的输入，所以会直接输出<code>$c&gt;file1</code>；</li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p><img src="/img/OS-Lab0/difficulty.png" alt="实验难点"></p><p>这里借用一下Hyggge学长的图，我个人认为写的非常好，我在进行线上实验的时候也注意到了这些难点，也是我经常在实验过程中回头去看指导书的地方。</p><p>在我自己的感觉里，我对<code>awk</code>命令和<code>grep</code>命令比较迷惑，也是看了很多攻略。其中<code>grep</code>命令的正则表达式和<code>java</code>的正则表达式不太一样，还得注意。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>对于计算机小白的我来说，刚开始接触命令行还是在大二上研究计组的时候。当初跟着同学里的大佬，在研究自动化测试的时候，慢慢开始接触命令行，学会用命令行解析、比对。当初确实感觉，相对图形化界面，命令行的一个极大的优点就是简洁。</p><p>当然，CLI对于计算机小白的我还是很有挑战性的。在刚开始使用CLI的时候，面对多种多样的指令、参数，我总是记不住它们的功能，写着写着还要重新去翻指导书，后来慢慢的才习惯了。</p><p>道阻且长，行则将至！诸君一起努力！</p><h1 id="原创说明"><a href="#原创说明" class="headerlink" title="原创说明"></a>原创说明</h1><p>本实验报告参考了Hyggge学长的<a href="https://hyggge.github.io/2022/03/21/os/os-lab0-shi-yan-bao-gao/">博客</a></p><p>另外致谢我的舍友風船同学，在学习过程中给了我很多帮助和解惑。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA_OS_2025 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
